## 7_2.内存空间扩充

### 7_2.1 覆盖

当要运行的程序大于内存大小时，可以将内存划分为固定区和多个覆盖区，首先需要**用户事先定义好**程序哪些部分不会被同时执行，那么这些独立的程序段就可以共享一个覆盖区，在调用到时调入内存，不需要时调出内存

### 7_2.2 交换

#### 7_2.2.1 定义

内存空间紧张时，将内存中的某些进程换出至磁盘，把磁盘中的某些处于就绪挂起、阻塞挂起的进程换入内存进行执行。在交换时，进程的PCB不会被换出内存

#### 7_2.2.2 实现

将磁盘分为文件区和对换区，被换出的进程会以连续分配存储空间的方式将其放入对换区

#### 7_2.2.3 对比

- 范围
  - 覆盖发生于一个进程的不同程序段之间
  - 交换发生于不同进程之间
- 用户透明
  - 覆盖要求用户必须定义好不同程序段之间的可覆盖关系
  - 交换对用户透明

### 7_2.3 虚拟内存

#### 7_2.3.1 局部性原理

##### 1）时间局部性

当前访问到的内存片段，不久之后很有可能再次被访问

##### 2）空间局部性

当前访问到的内存片段的前后区域，不久之后很有可能被访问到

#### 7_2.3.2 定义

根据局部性原理，将不久后会被用到的片段调入内存，其余暂时不用的部分放入外存并开始执行，执行中如果要访问的数据不在内存中，则再去外存中调取，这种使用**外存来暂存备用程序段的方式**即为虚拟内存技术

虚拟内存的最大容量是计算机寻址范围，实际容量为内存+磁盘的容量

#### 7_2.3.3 特征

- 多次性

  无需一次将大程序全部调度内存，可以分批调入

- 对换性

  只将需要用到的程序段动态调入内存中，将不需要的调出的外存

- 虚拟性

  从逻辑上扩充了内存的容量，内存的物理大小未变化

#### 7_2.3.4 实现

有下面三种管理框架

- 请求分页存储管理
- 请求分段存储管理
- 请求段页式存储管理

具体实现的功能与**基本**分页/段/段页存储管理的**区别**如下

- 请求调页/段/段页功能

  请求操作系统将外存中的程序段调入内存

- 页面/段/段页置换功能

  将暂时不需要的程序段从内存中调出之外存

### 7_2.4 虚拟内存-请求分页存储管理

#### 7_2.4.1 页表机制

由上面提到的两个功能可见，需要以下注意点

- 请求调页时，页面是否已经调入内存
- 页面置换时，页面是否被修改，是否需要覆盖外存中的备份

因而，与基本分页存储管理的页表对比如下

![image-20210202165118975](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210202165118975123.png)

#### 7_2.4.2 缺页中断机构

如上图中，如果要请求页号为0的进程段，此时不在内存中，则需要向操作系统发出缺页中断，此时该进程进入阻塞状态，由操作系统的缺页中断机构负责从外存中调入需要的页面，在调入成功后再进入就绪队列等待被调度，唤醒时，如果内存中

- 有空余的内存块用于分配刚调入的页面，则直接分配并开始进程的执行
- 没有空余的内存块，则由页面置换算法选择一个页面淘汰，如果被淘汰的页面被修改过则需要写回至外存，否则不需要

> 缺页中断属于**内中断**中的**故障**

#### 7_2.4.3 地址变化机构

通过页号找到页表中存储的页表项目时，如果页表项中的数据为空，则需要发出缺页中断来调入相应的页面，在内存空间充足的情况下，需要修改对应的页表项中的内存块号；否则，需要进行页面置换

同样的，该地址变换机构也可以引入快表来加速地址变换

#### 7_2.4.4 页面置换算法

##### 1）最佳置换算法（OPT算法）

- 机制

  每次淘汰的页面都是以后永不使用的或者长时间不会被使用的，保证了最低的缺页率

- 缺点

  只有进程运行过程中才能知道那些页面长时间不会被使用，无法进行预判，因而很难实现

- 示例

  ![image-20210202171405824](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210202171405824.png)

##### 2）先来先服务算法（FIFO算法）

- 机制

  每次淘汰的页面都是最早进入内存的页面

- 缺点

  算法性能差，内存块分配的越多，可能出现缺页率更高的现象，原因是老旧的数据可能一直占用内存块从而不能及时保证内存块中的数据足够新

- 示例

  ![image-20210202171833801](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210202171833801231.png)

  ![image-20210202171851227](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210202171851221237.png)

##### 3）最近最久未使用算法（Least Recently Used）

- 机制

  每次淘汰的页面是最近最久未使用的页面，从而需要对每个调入内存的页面记录每次被调入的最新时刻，在每次发生淘汰时可以计算每个字段截至目前已经多久没有被访问过

- 优、缺点

  - 缺点

    开销大，实现困难

  - 优点

    性能最接近OPT算法

- 示例

  ![image-20210202172225183](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210202172225183.png)

##### 4）时钟置换算法（CLOCK算法/Not Recently Used）

- 机制

  为每个页面设置一个访问位，再将内存中的页面都通过链接指针连接成一个循环队列，当某页被访问时，将其访问位设定为1。

  当要进行淘汰时，需要遍历循环队列，遍历查询队列中第一个为0的页面并将其换出，如果碰到1，则将其设定为0在访问下一个页面状态

- 特性

  性能和开销都均衡

##### 5）改进型时钟置换算法

- 机制

  在时钟置换算法中，由于每次淘汰页面不会考虑页面是否被修改过，如果被淘汰的页面没有被修改，那么就不必写回外存，直接丢弃即可，为了适应此改进，需要对页面添加状态标志位--"修改位"，1代表被修改过

  那么淘汰规则变为如下

  - 寻找两个标志位都为0的，如果未找到，也不修改任何标志
  - 寻找访问位=0，修改位=1的，一边遍历一边将访问位为1的置为0
  - 如果上一轮未找到，则寻找两个标志位都为0的，不修改任何标志位
  - 如果上一轮未找到，则寻找访问位=0，修改位=1的，一边遍历一边将访问位为1的置为0

  由于上面四步是一次执行完的，那么上面四步的查找的页面的具有如下特征

  - 最近没访问，没修改
  - 最近没访问，被修改
  - 最近访问过，没修改
  - 最近访问过，被修改

  上面四类页面优先级从上至下递减

- 特性

  算法开销较小，性能较好


