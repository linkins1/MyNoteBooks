## 7_1.内存分配与回收

### 7_1.1 连续分配管理方式

> 以下的分配方式中，不论哪种都是采用**从内存中划分出进程要求大小的连续整段内存**的方式

#### 7_1.1.1 单一连续分配

##### 1）定义

此类分配方式中，一般将内存分为

- **系统区**

  通常位于内存的低地址部分，用于存放操作系统相关的数据

- **用户区**

  通常位于内存的高地址部分，用于存放用户进程相关的数据

在进行内存分配时，严格按照区域进行分配，且内存**中至多只允许一个进程存在**，也即**每个进程独占用户空间**

##### 2）特性

- 优

  实现简单，无外部碎片

- 缺

  - 只能用于单用户、单任务的操作系统中
  - 有大量内部碎片

#### 7_1.1.2 固定分区分配

##### 1）定义

同样将内存划分为系统区和用户区，但是又对用户区**预先**进行了进一步划分，将用户区划分成了连续的子分区，根据分区是否等分可以形成两种划分方式，如下图所示

<img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/Untitled Diagram-Page-21.png" alt="Untitled Diagram-Page-21" style="zoom:80%;" />

为了管理不同的分区，需要创建一张分区状态表用于记录不同分区的**大小、起始地址和占用**情况，在进行内存分配时，需要根据用户进程的大小选取合适的分区进行分配

##### 2）特性

- 等分

  - 优

    适用于一台计算机控制多个大小相同的进程的情况

  - 缺

    缺乏灵活性

- 非等分

  - 优

    具有灵活性

  - 缺点

    不易确定划分准则，一般为大量多、适量中、少量小

两者共同的特性有

- 优

  实现简单、无外部碎片

- 缺

  - 用户进程太大时，可能无法找到满足要求的分区，这是需要内存扩充技术来支持
  - 存在大量内部碎片、不易管理

#### 7_1.1.3 动态分区分配

##### 1）定义

这种方式又成为可变分区分配，其同样会将内存划分为系统区和用户区，但是**不会讲用户区进行预先划分**，而是在程序装入内存时根据进程的大小**动态建立分区**

###### （1）维护

维护内存分区的方式一般有两种

- 空闲分区表

  这种方式类似于固定分区表，同样需要记录分区大小、起始地址和占用情况，但是在进程创建和回收的过程中需要频繁的创建、删除及更新表项，效率一般

- 空闲分区链表

  这种方式将每个表项抽象为一个链表中的节点，用于构成双向循环链表，这样可以使创建和删除操作更高效

###### （2）分配

在进行分配时，需要注意的是如何创建、更新和删除表项或者节点，动态分区分配算法有四大类

##### 2）特性

- 优

  没有内部碎片，内存分配灵活

- 缺

  有外部碎片，可以采用**紧凑法**（compaction）来解决，即将内存中的进程统一向一个方向进行移动以保证进程之间无外部碎片，但是移动代价太大

##### 3）动态分配算法

不同的算法都是为了解决**在有多块内存区域都可以分配时如何进行内存分配的问题**

###### （1）首次适应算法（First Fit）

- 方案

  每次都从低地址开始查找，找到第一个符合要求的空闲分区并进行划分

  要求空闲分区表/空闲分区链表**以空闲分区递增的顺序**进行表项/节点排列

- 特性

  - 优
    - 综合性能最好，开销小，**回收分区后一般不需要对空闲分区表/链表进行重新排列**
    - 当低地址部分有更小满足要求的分区可以分配时，可以在高地址保留更大的空闲内存

###### （2）最佳适应算法（Best Fit）

- 方案

  由于此种分配方式是连续分配，为了保证较大进程分配时有大的空闲分区供其使用，因而每次进行内存分配时要找到最小的可以满足进程要求的空闲分区进行分配，也即优先使用小分区、保留大分区

  这要求**空闲分区按容量递增的顺序排列**，每次分配内存时顺序查找空闲分区链表/表，选取第一个满足要求的空闲分区进行分配

- 特性

  - 优

    可以保证更多的大的分区被保留

  - 缺

    - 会产生**大量小的难以利用的**外部碎片
    - 算法开销大，需要对空闲列表进行重新排序

###### （3）最坏适应算法（Worst Fit）

- 方案

  与最佳适应算法相反，为了减少过多的小的外部碎片，其优先使用大的空闲分区

  这要求**空闲分区按容量递减的顺序排列**，每次分配内存时顺序查找空闲分区链表/表，选取第一个满足要求的空闲分区进行分配

- 特性

  - 优

    减少了难以利用的小的内存碎片

  - 缺

    - 不会保留大的空闲分区，不利于大进程的内存分配
    - 算法开销大，需要对空闲列表进行重新排序

###### （4）临近适应算法（Next Fit）

- 方案

  这种方式是首次适应的改版，其每次不是从低地址开始查询，而是**从上次查找结束的位置继续查找**

  这种方式使用双向循环链表会更加高效，更便于循环查找，**具体做法是**，将空闲分区链表按照地址递增的顺序排列好后，每次从上次查找结束的位置开始查找，在进程内存分配结束后，如果有新的空闲分区被划分出，需要在此位置创建新的空闲分区节点

- 特性

  - 优

    从全局进行内存分配，使内存全局等概率的被使用

  - 缺

    不论低地址和高地址的空闲内存分区都有相同的概率被使用，导致高地址部分的大分区更可能被使用，这样在全局内存空间上都不会有大的空闲内存被保留，同样不利于大进程的内存分配

### 7_1.2 非连续分配管理方式

>以下的分配方式中，不论哪种都是采用**从内存中划分出进程要求大小的不连续的分段内存**的方式

#### 7_1.2.1 基本分页存储管理

##### 1）定义

把**内存**划分成**大小相等**的多个分区，每个分区称作一个**页框**，每个页框有一个**页框号**，页框号从0开始；

之后，把用户进程的**逻辑地址空间**划分为**和页框大小相等**的一个个区域，称为**页面**，每个页面有一个**页号**，页号从0开始

在为进程分配内存时，操作系统将进程**以页为单位放入一个个页框中**

**综上**，

- 页面和页框的大小相等
- 页面是进程逻辑地址空间按页框的大小划分后的一个部分
- 页框是内存上被划分出的一个区域，每个区域大小相等，等待被放入页面

> 页框有如下**别名**
>
> - 页帧
> - 内存块
> - 物理块

##### 2）地址转换

由于每个页面可以被放入分散的页框中，为了能够进行逻辑地址到物理地址的转换，就需要知道如下信息

- 进程中某一逻辑地址所在的**页号x**

- 页号为x的**页面在内存中的起始地址**
- 进程中某一逻辑地址在此页中的**页内偏移量**
- 物理地址等于**页面起始物理地址+页内偏移量**

###### （1）页内偏移量和页号

其中，页号和页内偏移量计算公式如下

页号 = 逻辑地址/页面大小

页内偏移量 = 逻辑地址%页面大小


**举例如下**，

设页面大小为50，页号为1的起始物理地址为100，进程中逻辑地址为80的字段在内存中的物理地址是多少？

**解：**

​		**∵** 页号 = 80/50 = 1

​		    页内偏移量 = 80%50 = 30

​		**∴** 物理地址 = 100 + 30 = 130

  一般来说，为了简化计算机计算页号和页内偏移量，通常要求页面大小是2的指数，

**举例如下**，

设页面大小为1024，逻辑地址位数为32，求逻辑地址为3325的页号和页内偏移量

**解：**

​		由于页面大小为1024，那么0号页的逻辑地址空间如下

​		00000000 00000000 00000000 00000000 -->	00000000 00000000 00000**0**11 11111111

​		1号页的逻辑地址空间如下

​		00000000 00000000 00000**1**00 00000000 -->	00000000 00000000 00000**1**11 11111111

​		2号页的逻辑地址空间如下

​		00000000 00000000 0000**1**000 00000000 -->	00000000 00000000 0000**1**011 11111111

​		3号页的逻辑地址空间如下

​		00000000 00000000 0000**11**00 00000000 -->	00000000 00000000 0000**11**11 11111111

从上可知，低10位表示页内偏移量，高22位表示页号，所以计算页号只需和下面数字与运算

​		11111111 11111111 11111100 00000000

计算页内偏移量只需和下面数字与运算

​		00000000 00000000 00000011 11111111

###### （2）页号与物理地址

通过前面，已经解决了如何计算页号和页内偏移量的问题，**但是**，还必须知道每个**页号对应的物理地址是多少**，这就需要引入**页表**用来记录**每个页号与页框号之间的对应关系**

页表具有如下性质

- 每个进程独有一张页表
- 每一行是一个页表项，key为页号，value为页框号

- 存储一个页框号需要的内存大小与页面大小也即页框大小有关

**举例`A`如下**，

设定物理内存为4GB，页面大小为4KB，求每个页表项中页框号至少需要多少字节来存储？

**解：**

​		∵ 4GB = 2^32B , 4KB = 2^12B 

​		∴ 页框数量 = 2^32/2^12 = 2^20 个，也即**页框号的取值范围**是0~2^20-1

​		又 ∵ 要表示2^20个页框号至少需要3字节，所以每个页框号至少需要3字节来存储，如下所示

![image-20201117213006493](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201117213006493.png)

这里需要注意，**页号的数量**计算如下

页号的数量 = 进程的逻辑地址空间的大小（进程占用的内存大小）/页面大小


> 一般**页框号占用的大小即为页表项占用的大小**，因为页表是连续存放在内存中的，所以只需要记录页表在内存中的起始物理地址和页号即可计算出对应的页表项所在的物理地址，此地址对应存放的就是页框号

###### （3）基本地址转换机构

基本地址变换机构负责将逻辑地址转换为物理地址，**其组成部分如下**

- **页表寄存器**

  存放页表在内存中的起始物理地址和页表长度

- **页表**

  在进程未执行时，页表起始地址和页表长度会被存放在PCB中，当进程被调度时，操作系统将其放入页表寄存器

**在给定页表项大小为`K`、页面大小为`L`、逻辑地址为`A`之后，其转换步骤如下**

- 通过`A`计算出页号`P`和页内偏移量`W`
- 比较`P`和页表长度，如果`P>=页表长度`，则越界，否则下一步
- 由于给定了页表的起始物理地址`F`，所以要查询的页框号所对应的物理地址为`F+K*P`
- 取出页框号为`B`，所以A对应的物理地址为`0+L*B+W`

**由上可知**，

- 页式管理中，地址是一维的，因为只要知道逻辑地址就可以确定出物理地址
- 需要进行两次内存访问，一次是查询页框号，一次是访问逻辑地址对应的物理地址中的内容

> 为了方便确定页表项所在的物理地址，一般选取可以让**页面**装下**整数个**页表项的页表项大小
>
> 例如，前面的**例子`A`**中，存储页表项最小的最小字节数为3字节，但是由于页面大小为4KB，所以每一页中只能装下1365个页表项，这样每一页都会剩下1KB大小的空闲，假设页表的起始物理地址为F，第0页存储了0~1364号页表项，那么1365号页表项就会存储到第一页的开始，那么1365号页表项所在的物理地址为**F+1365*3KB+1KB**，也即需要将最后空余的1字节也算入才可以得到正确的物理地址。
>
> **所以**，一般选取可以让**页面**装下**整数个**页表项的页表项大小

###### （4）具有快表的地址变换机构

- 局部性原理

  - 时间局部性

    如果内存中某段数据被访问过，那么很有可能被再次访问

  - 空间局部性

    如果内存中物理地址为A的资源被访问过，那么A附近的内存也有可能被访问到

- 快表（**T**ranslation **L**ookaside **B**uffer）

  是一种Cache，访取速度远快于内存，用来存放**最近被使用的页号及对应的页表项中存储的页框号**，这样每次都会先查询快表，如果快表中没有，再去查询**页表寄存器**；这样便省去了一次计算页框号所在物理地址并查询页表找到对应页框号的开销，在局部性原理的支持下，加速了查询页表项的过程，也就加速了地址转换过程

相比于只使用页表寄存器，使用快表后，**如果在快表内命中，那么只需要进行一次内存访问**，也即最终的物理地址的访问

###### （5）两级页表

首先考虑**单级页表的问题**

- 页表需要连续存放于内存中
- 实际可能只使用少量的个别页表项，不需要将整个页表一直存储在内存中

通过上面的问题，自然想到对页表进行划分，并对此划分再建一张表称为**页目录表**，也称为外层页表/顶级页表

假设对单级页表按1024个页表项为一组进行分组，

设页目录表含有1024项，那么原来的0号页变为现在的页目录表中的第0#项作为一级页号，其中存储此项在内存中的起始页框号，二级页表就存储在此页框号开头的连续的内存空间中，二级页表中的页表项存储着最终物理地址所在的页框号，结合此页框号和页内偏移量即可得到最终的物理地址

那么对于下面的逻辑地址，设页面大小为4KB，其转换为物理地址的步骤如下

```text
0000001000 	0000000111 	0000 00000000
```

由于页面大小4KB，按字节编址，那么每一页的地址容量为2^12，那么页内偏移量需要12位来表示

由于页目录表容量为1024，需要10位来表示，这样还剩下10位，可以让二级页表容量也为1024，所以32位的逻辑地址空间就被划分为**10位+10位+12位**

**所以转换步骤为**

- 取高10位得出目标二级页表所在的页框号A
- 取中间10位得出目标物理地址所在的页框号B
- 根据页框号B和低12位也即页内偏移量即可得出最终的物理地址

从上可知，两级页表需要**3次**内存访问，多的一次即为在一级页表中查询二级页表的页框号的访问

#### 7_1.2.2 基本分段存储管理

##### 1）分段

由于程序代码中，地址空间可以按照自身的逻辑进行划分，如按照函数体划分，那么**每个划分就可以看作是一个段**，每个段从0开始编址

那么在进行**内存分配时**，就以分段为单位向内存进行分配，**每个段占据连续的地址空间，但是各段可以离散**

##### 2）逻辑地址

分段的逻辑地址结构类似于单级页表的管理方式，分为段号和段内偏移量，那么为了完成从逻辑地址到物理地址的转换，就需要段表来记录**段号和物理地址**之间的关系，这样才可以找到每一段在内存中的起始物理地址，并根据段内偏移量计算出真实的物理地址

> 在进行地址转换时，由于机制和单级页表很类似，所以也可以通过引入快表机制来加速地址转换

##### 3）与分页的比较

- 连续分配

  分段和分页来讲，每一段/页在内存中都是连续分配的

- 单位量

  段的大小可以是各不相同的，但是页的大小是固定的，且页面必须放在页框中

- 内存空间划分

  对于分段来讲，不需要对内存空间进行等量划分，只需要记录段号对应的物理地址即可与段内偏移量一同确定最终的物理地址

  对于分页来讲，需要将内存空间进行等量划分，需要根据页号查找对应的页框号，再由页框号、页框大小和业内偏移量得出最终的物理地址

- 用户可见性

  分页这个操作对用户是不可见的，是完全的系统行为，用户只需要给出逻辑地址即可

  分段对用户是可见的，因为用户需要显示的给出段号和对应的逻辑地址

- 用户进程地址空间维度

  分页是**一维**的，因为程序员只需要记录逻辑地址就可以最终成功的映射到一个物理地址

  分段是**二维**的，因为程序员需要给出逻辑地址中哪一部分是段号哪一部分是段内地址

  如此来看，分段类似于将操作系统负责的分页操作提前完成了，只不过是按段进行划分，但是仍然需要操作系统负责构建段表，从而给出段号对应的起始物理地址

- 碎片

  分页在页面不填满的状态会产生内部碎片

  分段在段长很大时容易产生外部碎片

#### 7_1.2.3 段页式存储管理

##### 1）定义

为了综合分段不产生内部碎片和分页不产生外部碎片的优势，可以先对用户进程地址空间进行分段，之后再将各段进行分页，最终再把各个页面放入页框中

##### 2）逻辑地址

由于用户仍然需要显示的指定段号和段内地址，但是由于在分段后又进行分页，所以需要对段内地址再进行划分，分为页号和页内偏移量，如下图所示（截取自王道考研）

![image-20201120212106084](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201120212106084.png)

> 如果上面按两个字节编址，那么会影响最终内存块的大小，即`2^12个存储单元*2B=8KB` 原来是`2^12个存储单元*1B=4KB`

那么进行地址转换时，段表的结构也会发生变化，如下所示

![image-20201120212215584](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201120212215584.png)

这样在进行地址转换时就需要进行**三次内存访问**，也即查段表+查页表+查最终的物理地址，同样可以引入快表机制来加速地址转换

