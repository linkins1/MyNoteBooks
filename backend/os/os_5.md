## 5.进程同步/互斥

### 5.1 基本概念

#### 5.1.1 定义

##### 1）同步

进程同步发生于**多个进程共享访问存取同一个资源时**，为了保证资源能被安全的访问，需要严格控制各个进程执行的次序，以特定手段（如互斥）来指定不同进程对资源访问次序的方式即为**进程同步**

##### 2）互斥

###### （1）资源共享的方式

- 互斥共享方式

  一个资源提供给多个进程使用，但是一个时间段只能有一个进程访问，这类资源称为**临界资源**

- 同时共享方式

  一个资源提供给多个进程使用，且同时可以有多个进程“同时”访问

###### （2）定义

进程互斥指一个进程访问在访问临界资源时，其他进程**必须等待**，直到当前访问进程让出资源或者退出

#### 5.1.2临界区

对临界资源的互斥访问分为下面四个部分

<img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201103200333844.png" alt="image-20201103200333844" style="zoom:80%;" />

如上图所示，

- 临界区是进程中访问临界资源的代码段
- 进入区和退出区是负责实现互斥的代码段

为了保证互斥访问，需要遵循下面**四条规则**

- **空闲让进**

  临界区**空闲时**，可以允许另一个请求进入临界区的进程**立即进入**

- **忙则等待**

  当已有进程进入临界区时，其他**试图进入**的进程**必须等待**

- **有限等待**

  对请求访问的进程，需要保证其能在**有限时间内访问到**临界区

- **让权等待**

  当进程不能访问临界区时，必须**立即让出**CPU，避免**忙等待**

### 5.2进程互斥实现方法

> 进程互斥主要是规定各个区域应当如何执行，时刻牢记下面四个区
>
> - 进入区
> - 临界区
> - 退出区
> - 剩余区

#### 5.2.1软件实现

##### 1）单标志法

###### （1）定义

多个进程轮流的访问各自的临界区，等待中的进程的访问权限**只能由**执行中的一个进程来赋予

###### （2）示例

<img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201103202746173.png" alt="image-20201103202746173" style="zoom: 67%;" />

执行步骤如下

- turn=0，P0①不满足，进入临界区②
- ②过后，执行③，设定turn为1
- 如果P0时间片没耗尽，则继续执行④，否则调度到P1
- P1①不满足，进入临界区②
- ②过后，执行③，设定turn为0
- 如果P1时间片没耗尽，则继续执行④

如果P0和P1都循环执行，那么执行顺序将是P0->P1->P0->P1->...

###### （3）特性

- 在进入区进行**检查**操作，同时只能有一个进程访问
- 如果P0得到执行权但迟迟不访问临界区，那么P1也不能访问P1的临界区，**不满足"空闲让进"原则**

##### 2）双标志先检查

###### （1）定义

设定一个布尔型数组`flag[]`，数组中的各个元素记录各个进程是否想要进入临界区，如果想要进入且可以进入，则设定flag对应元素为`true`，每个进程在进入临界区之前都会检查是否有其他人想进入临界区（flag数组中是否有true），如果有，则等待；如果没有则进入，并将对应位置设为`true`，在访问结束后，将flag对应位置设为`false`

###### （2）示例

![image-20201103204001231](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201103204001231.png)

###### （3）特性

- 在进入区进行**检查**和**上锁**操作
- 如果执行顺序为①⑤②⑥，那么将会有两个进程都进入临界区，**违背了"忙则等待"原则**，造成这种现象的原因是**进入区的检查操作和上锁操作不是一次完成的**

##### 3）双标志后检查

###### （1）定义

与双标志先检查不同**仅在于是先（设定flag数组）上锁后检查**

###### （2）示例

![image-20201103204632645](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201103204632645.png)

###### （3）特性

- 在进入区进行**上锁**和**检查**操作，保证了同时只有一个进程访问临界区
- 如果执行顺序为①⑤②⑥，那么两个进程将都无法进入临界区，卡在进入区，**违背了"空闲让进"和"有限等待"原则**

##### 4）Peterson算法

###### （1）定义

是双标志后检查法的改进版本，为了避免两个进程都上了锁但是都卡在进入区检查的问题，可以要求某个进程主动解锁，让出执行权，让另一个进程进入临界区

###### （2）示例

![image-20201103205044421](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201103205044421.png)

###### （3）特性

- 在进入区主动争抢上锁->主动让出执行权->检查对方是否想进入以及对方是否让出资源
- 满足了**空闲让进，忙则等待，有限等待，但是不满足让权等待**
  
  - 假设按照①⑥②③⑦⑧③的顺序，在P0第一次执行③时，如果按照**让权等待**原则，应该让P1立即进入临界区，**但是**，由于Peterson算法规定，获取到锁之后**要立即让出执行权一次**，所以P1第一次执行到⑧时也会卡死，不能进入临界区，且没有让P0立即进入临界区，需要等待P1时间片耗尽后，再次进入P0的③跳出循环后进入临界区
  
  > A：我要进，你等等 
  >
  > B：我要进，你等等 
  >
  > A：算了你先来吧（呆住...）
  >
  > B：算了你先来吧（呆住...）
  >
  > A：那么我先来
  >
  > A：我完事儿了，你来吧
  >
  > B：好的

#### 5.2.2硬件实现

##### 1）中断屏蔽方法

###### （1）定义

利用开/关中断指令，在进入区关闭中断，保证临界区执行过程不被打断，执行过后开中断，恢复原来的状态

> 达到的效果和原语类似

###### （2）优缺点

- 优

  简单高效

- 缺

  不适用于多处理机，只适用于内核态，用户态不被允许使用

##### 2）TestAndSet（TS指令/TSL指令）

###### （1）定义

使用硬件实现，其等效的逻辑用C语言描述如下

![image-20201105201013959](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201105201013959.png)

- 如果开始lock为false，则返回TestAndSet返回false，则跳出循环，且此时已经上锁（lock已经等于true）
- 其他进程再次执行TestAndSet会返回true，卡在while，直到刚拿到锁的进程退出临界区并将lock置为false

###### （2）优缺点

- 优

  采用硬件的方式保证**检查和上锁**两个操作**一次完成**，实现简单，不存在漏洞，适用于多处理机环境

- 缺

  如果某个进程执行TestAndSet后不能跳出循环，那么会一直卡在循环中占用CPU，会不满足**"让权等待"**原则

##### 3）Swap指令（XCHG指令）

###### （1）定义

也是由硬件实现的，执行过程中不能被中断，其逻辑用C语言描述如下

![image-20201105202700622](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201105202700622.png)

- 由于old一开始为true，在lock未被上锁时，其为false
- 进入while循环，交换lock和old，此时lock为true，old为false（代表第一次上锁），则跳出while，进入临界区

其逻辑和TestAndSet类似

###### （2）优缺点

- 优

  采用硬件的方式保证**检查和上锁**两个操作**一次完成**，实现简单，不存在漏洞，适用于多处理机环境

- 缺

  对于old为true的，会一直卡在while中占用CPU，同样不满足**"让权等待"**原则

#### 5.2.3信号量

##### 1）定义

信号量是一种变量，表示系统中某种资源的数量，对信号量操作只能由操作系统提供的下面一对原语来实现，S代表信号量

- wait(S)--proberen--P操作
- signal(S)--verhogen-V操作

##### 2）分类

###### （1）整型信号量

用一个整型变量来作为信号量，表示系统中某种资源的数量

![image-20201105205333810](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201105205333810.png)

###### （2）记录型信号量

由于整型信号量和TestAndSet类似，都会出现循环检查的情况，因而使用记录型的数据结构（如队列）表示信号量

<img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201105205607662.png" alt="image-20201105205607662" style="zoom:80%;" /> 

其wait原语逻辑如下

<img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201105205702398.png" alt="image-20201105205702398" style="zoom:80%;" /> 

其signal原语逻辑如下

<img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201105205730012371.png" alt="image-20201105205730071" style="zoom:80%;" /> 

**综上**，P，V操作有如下特征

- 对信号量S做一次P操作相当于进行一次资源申请，如果成功则资源数减1，否则进入阻塞队列（block原语）
- 对信号量S做一次V操作相当于进行一次资源释放，此时会唤醒（wake原语）阻塞队列中的一个进程来执行

通过使用阻塞队列，满足了**"让权等待"原则**

##### 3）信号量实现同步

###### （1）进程互斥

按如下步骤实现

- 设定互斥信号量`mutex=1`
- 在临界区前执行`P`操作
- 在临界区之后执行`V`操作

P，V操作必须成对出现，否则会出现进程卡死的现象

<img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201105210627563.png" alt="image-20201105210627563" style="zoom: 67%;" /> 

###### （2）进程同步

为了保证进程并发执行过程中**满足某种指定顺序**，假设顺序在前的进程为P1，在后的进程为P2按如下步骤执行

- 设定同步记录型信号量`S为0`
- 在P1中的操作区域之后执行`V`操作
- 在P2中的操作区域之前执行`P`操作

示例图如下

<img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201105211030669.png" alt="image-20201105211030669" style="zoom:80%;" />

- 如果先执行P1中的V操作，那么满足既定顺序，信号量加1，之后P2执行P操作不会被阻塞，进入代码4
- 如果先执行P2中的P操作，那么会被阻塞，之后执行P1中的V操作，唤醒被阻塞的P2，进入代码4

**综上**，可见不论以那种方式执行，都可保证代码1，2在代码3，4之前执行

###### （3）进程前驱关系

参见进程同步的思想，对于要求多个进程按某种顺序执行的要求，只需要在"前操作"之后执行`V`操作，在"后操作"之前执行`P`操作即可。见下面例子

<img src="C:%5CUsers%5C123%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201105212308470.png" alt="image-20201105212308470" style="zoom:67%;" /> <img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201105212344390.png" alt="image-20201105212344390" style="zoom:67%;" />

> 此处P1中的多个V操作的顺序可以任意放置

### 5.3IPC(Inter Process Communication)案例

#### 5.3.1单生产者-单消费者

##### 1）问题模型

生产者和消费者共享一个初始为空，大小为n的缓冲区，生产者和消费者遵循下面准则

- 只有缓冲区没满时，生产者才可以将产品放入缓冲区，否则必须等待
- 只有缓冲区不空时，消费者才可以从缓冲区中取走产品，否则必须等待
- 各个进程必须互斥的访问缓冲区

##### 2）解答

存在两对同步关系，一对互斥关系

- 同步

  - 满，生产晚于消费
  - 空，消费晚于生产

- 互斥

  生产时不可消费，消费时不可生产

![image-20201106202437945](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201106202412337945.png)

<img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201106202843016.png" alt="image-20201106202843016" style="zoom: 67%;" />

> ***Q：*****P操作的顺序可以更换吗？**
>
> ***A：***不可以，对于生产者来说，先拿到mutex后，如果empty为空，那么P(empty)就会阻塞，同时也不会放mutex的锁，那么当消费者进入时，先执行P(mutex)此时会被阻塞，那么生产者和消费者就都陷入永久的阻塞状态，**构成死锁**

#### **5.3.2**多生产者-多消费者

##### 1）问题模型

生产者`A`生产橘子，生产者`B`生产苹果，消费者`A'`消费橘子，消费者`B'`消费苹果，当盘容量为1或大于1时，该如何保证有序生产消费

##### 2）解答

###### （1）盘子容量为1

存在两对同步，两对互斥关系

- 同步

  A'在A之后消费，B'在B之后消费

- 互斥

  盘子必须被互斥的访问

下图中，可暂时忽略mutex参数

plate代表盘子是否为空，初值为1

apple代表苹果是否为空，初值为0

orange代表橘子是否为空，初值为0

![image-20201106203947350](C:%5CUsers%5C123%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201106203947350.png)

###### （2）盘子容量>1

与上图相同，且不可以删掉mutex互斥量，由于可能存在父亲先获得盘子，之后母亲也获得盘子，如果没有mutex，此时父亲先放入苹果，之后母亲放入橘子，但是**母亲放入的橘子可能会覆盖掉父亲的苹果**，因而不能仅靠盘子的容量为标准，还必**须添加一个代表是否占用盘子的信号量mutex**，这样可以保证正确执行

#### 5.3.3吸烟者

##### 1）问题模型

![image-20201106205217820](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201106205217820.png)

##### 2）解答

将每一对组合看作是一个资源，那么就存在offer1，offer2，offer3三种资源，此外，生产者和所有抽烟者必须互斥的访问桌子，或者说是生产者必须晚于抽烟者放入组合，这样存在四对同步关系

- 抽烟者1晚于生产者提供offer1
- 抽烟者2晚于生产者提供offer2
- 抽烟者3晚于生产者提供offer3
- 生产者晚于抽烟者提供offer

![image-20201106212257010](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201106212257010.png)

> ***Q：*****此例中需要必须提供互斥量访问桌子吗？**
>
> ***A：***不需要，由于三个抽烟者轮流抽烟且offer数量最多为1，且提供了信号量来保证生产者在抽烟者执行之后放置offer，所以不需要提供互斥量

#### 5.3.4读者-写者

##### 1）问题描述

有一组读者进程和一组写者进程，按如下要求执行

- 允许多个读者进程同时对文件进行读操作
- 同时只允许一个写者进行写操作
- 任一写者完成前读者不可以进行读操作
- 写者执行写操作前，所有其他读者和写者都应退出

##### 2）解答

![image-20201107193105560](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201107193105560.png)

使用**count**来记录读者进程的数量，由第一个读进程进入时上锁，最后一个读进程退出时解锁

#### 5.3.5哲学家就餐

##### 1）问题模型

桌子上有五位哲学家，哲学家之间有一根筷子，哲学家必须其左右手两边的筷子才可以就餐，如何能保证哲学家有序的就餐且不会出现死锁

##### 2）解答

###### （1）解法一

让奇数号哲学家先拿左手边筷子，拿到后再去拿右手边筷子；让偶数号哲学家先拿右手边筷子，拿到后再去拿左手边筷子

###### （2）解法二

让拿筷子这件事互斥，即当一个哲学家获得拿筷子的权力后（尽管他只需要其左右手两边的筷子），其他哲学家就必须等其拿完筷子再去争夺拿筷子的权力

<img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201108202030778.png" alt="image-20201108202030778" style="zoom:67%;" />

### 5.4管程（监视器Monitor）

> 由于使用信号量机制来确保同步十分复杂，因而提出利用**封装的概念**来完成同步

#### 5.4.1定义

管程是一个特殊的软件，其具有如下特性

- 局部于管程内部的**共享数据结构**，并对其初始化
- 对该数据操作的过程（函数）
- 每次**只允许一个进程**在管程内执行，使用互斥锁来保证这一点，且互斥特性由编译器来实现

常用的MESA模型如下（[图片来源](https://www.itread01.com/content/1580216895.html)）

<img src="https://img2018.cnblogs.com/blog/1099419/202001/1099419-20200128201152301-1784803913.png" alt="img" style="zoom: 67%;" />

#### 5.4.2应用

![image-20201108203501557](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201108203501557.png)

> Java中的synchronized关键字也是类似于管程的存在，保证了每次只有一个线程在管程内执行

### 5.5死锁

#### 5.5.1基本概念

##### 1）定义

死锁即每个进程/线程互相等待他者占有的资源，而出现闭环等待的现象

##### 2）对比

![image-20201108203841404](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201108203841404.png)

##### 3）产生条件

- 互斥条件

  共享资源同时只有一个进程可以使用

- 不可剥夺条件

  进程已经占有的共享资源不可被其他进程抢占

- 请求并保持条件

  进程已经拥有一个资源但又请求其他资源

- 循环等待条件

  多个进程在等待其他线程释放资源，构成闭环

> ***Q：*****循环等待一定发生死锁吗？**
>
> ***A：***不一定，如果被占有的资源不止一个（有多个A资源），尽管发生循环等待也不会构成死锁，**但是**，发生死锁时一定会出现循环等待现象

##### 4）产生时机

- 多个进程对**系统资源**（不可剥夺）竞争
- 进程获取资源顺序非法
- PV操作不当

#### 5.5.2死锁处理

##### 1）预防死锁

提前破坏死锁的四个条件之一

###### （1）破坏互斥条件

采用软件方式在逻辑上使互斥资源可以被同时使用，如SPOOling技术，可以将多个请求打印机的进程放入队列后依次执行，这样反映在请求方即为共享使用打印机

**但是**，并不是所有的互斥资源都可以被改造，对于严格要求互斥的资源，此条件不可以被破坏

###### （2）破坏不可剥夺条件

- 及时释放

  当某个进程在请求新资源时，如果不满足条件，则需要将其现阶段持有的共享资源全部释放

- 外力辅助

  当某个优先级较高的进程需要获取某个共享资源时，由操作系统来负责夺取该资源并分配给它

**但是**，此策略有如下缺点

- 实现复杂
- 反复切换进程/线程会带来较大的开销

###### （3）破坏请求并保持条件

采用静态分配的方法，在进程启动时就将其需要的全部资源一次性分配完成，如果不能全部分配，则等待可以分配为止

**但是**，这样会大大降低资源的利用率，对某些只需要短暂占用的资源，其利用率会降到更低

###### （4）破坏循环等待条件

采用顺序分配资源法即每个进程都按照固定的顺序去申请资源，这样就不会出现要申请的资源已经被他者占用的情况

**但是**，这具有如下问题

- 当需要新增共享资源时，需要重新排列申请顺序
- 进程实际使用到的共享资源数可能很少，按照静态的顺序申请会带来不必要的操作

##### 2）避免死锁

采用某种方法避免系统进入不安全的状态，这里介绍银行家算法

###### （1）基本概念

- 安全序列

  即一种分配资源的顺序，只要系统按照这个顺序进行资源分配就可以保证每个进程都安全的执行

  如下例子，设有本金100

  ![image-20201108211456868](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201108211456868.png)

- 不安全状态

  如果分配了资源之后，系统找不到一个安全序列，那么系统进入了不安全状态

- 与死锁的联系

  只要处于安全状态，系统就不会出现死锁

###### （2）银行家算法

- 定义

  在系统进行资源申请时，**预判**此次分配是否会导致系统进入不安全状态，如果会，则让此进程先进入阻塞状态

- 示例

  <img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201108211749785.png" alt="image-20201108211749785" style="zoom: 67%;" />

  假设现有资源为`(10,5,7)`，在已分配的状态下还有`(3,3,2)`，下面开始**安全性检查**

  - P0还需要的资源大于剩余，不分配
  - **P1**还需要的资源全部小于剩余，可以分配，在其归还后系统资源还有`(5,3,2)` :one:
  - P2需要的资源大于`(5,3,2)`，不分配
  - **P3**还需要的资源小于`(5,3,2)`，可以分配，在其归还后系统资源还有`(7,4,3)` :two:
  - 这时`(7,4,3)`已经满足**P0**当时的申请，可以分配，归还后还有`(7,5,3)` :three:
  - `(7,5,3)`满足**P2**当时的申请，可以分配，归还后还有`(10,5,5)`​ :four:
  - **P4**需要的资源小于`(10,5,5)`，可以分配，**归还后已完成了一次全部分配**​ :five:

  这样，在上面的给定已分配状态下，可选的一个安全序列为:one:->:two:->:three:->:four:->:five:

- 示例抽象

  通过上面的示例，假设系统中有n个进程，m种资源，那么

  - 最大需求可以抽象为MAX矩阵，行代表进程，列代表对每种资源的最大需求
  - 已分配可以抽象为ALLOCATION矩阵，行代表进程，列代表已获得的每种资源的数量
  - 最多还需要可以抽象为NEED矩阵，行代表进程，列代表对每种资源最多还需要多少
  - 用REQUEST矩阵代表此次请求获得的资源
  - 用AVAILABLE表示系统当前剩余的资源

  之后进行**如下步骤**

  - 如果REQUEST>NEED，那么出错，否则进入下一步
  - 如果REQUEST<AVAILABLE，那么进入下一步，否则**阻塞**当前请求进程
  - 进行一次测试，在假设已分配给当前请求的条件下执行**安全性检查**算法（也即上面例子中的检查步骤），检查**是否会进入不安全状态**
    - 检查当前AVAILABLE可否满足某个进程的NEED，可以则加入安全序列，并将其资源全部回收
    - 重复上一步，检查安全性序列是否可以构建完成，如果完成则返回安全；否则不安全

> ***Q：*****为何银行家算法可以保证没有死锁发生？**
>
> ***A：***由于**每次进行资源分配**时，都用安全性算法检查**保证了**分配后，**存在**一个安全性序列使得每个进程在申请其想要的最大资源数时都保证能被分配到，这样可以确保系统可以有机会维持在安全状态
>
> 安全性算法是在最坏条件下的打算，如果可以通过测试，代表可以放心执行

##### 3）检测与解除死锁

由操作系统负责检测和解除

###### （1）死锁检测

- 资源分配图
  - 两种结点
    - 进程节点：对应于一个进程
    - 资源节点：对应于一类资源，其中可能包含多个资源
  - 两种边
    - 进程节点->资源节点：表示进程想要申请资源，一个边代表想申请一个资源
    - 资源节点->进程节点：表示已经为进程分配了资源，一条边代表一个资源

- 图可完全简化

  :one: **示例A**

  如下所示的一个资源分配图

  ![image-20201109193114829](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201109193114829.png)

  其中，绿色边代表已经分配的边，蓝色边代表进程请求资源

  - 进程节点`A`已经被分配了两个资源`1`，并请求资源`2`
  - 进程节点`B`已经分配了一个资源1和一个资源`2`，并请求资源`1`

  下面开始对图进行简化，由于进程节点B在申请资源1时已经没有多余的资源，因而会被阻塞；同时，由于`A`向`2`申请蓝色边时，资源`2`恰巧还有一个资源，因而进程节点`A`是可以成功执行完并返回其全部资源的，**这时**，可以删除和`A`相连的**全部边**，包括已经分配的边和请求的边，这样进程节点`A`就变为**孤立节点**

  之后资源节点`1`还有两个资源，满足`B`的要求，这样`B`也可以删除和其连接的全部边，**此时**，图中已经**不存在任何边**，那么就称这张资源分配图是**可完全简化**的

  :two: **示例B**

  ![image-20201109194000899](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201109194000899.png)

  如上的资源分配图中，可以成为**孤立节点**的只有进程节点`C`，之后`A`和`B`都回进入阻塞状态，此时就构成了**死锁**，此时称这个资源分配图是**不可完全简化**的；那么，**不可完全简化和死锁也就是等价的概念**

###### （2）死锁拆除

在通过资源分配图检测到有死锁存在时，可以采用如下方法对**仍有边相连的进程**进行拆除

- **资源剥夺法**

  将某个死锁进程挂起并将其拥有的资源分配给其他进程，但是要注意避免被挂起的进程出现饥饿状态

- **撤销进程法**

  强制撤销某些进程，并剥夺其资源

- **进程回退法**

  在进程执行过程中设置记录点，在发生死锁时将进程回退至安全的记录点，并将被释放的资源进行分配

