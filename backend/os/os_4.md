##  4.调度

> ***Pre***
>
> :one: 
>
> 进程调度实现了根据不同进程当前的状态，解决了
>
> - 决定哪个作业可以被放入就绪队列
> - 决定哪个挂起的/阻塞的/**运行中的**进程被放入就绪队列
>
> - 如何从就绪队列中选取进程分配CPU使用权**（最主要）**
>
> 其核心目的是**为了最大化CPU利用率**
>
> :two:
>
> 进程同步解决了**进程间通信（Inter Process Communication）的同步和互斥问题**，其**会影响进程调度**（影响阻塞队列、就绪队列的排列），目的是**保证临界资源被各进程轮流的安全访问**
>

### 4.1基本概念

#### 4.1.1定义

在**资源有限**的状态下，处理机需要设定规则来决定不同任务的**执行次序和时间**；

处理机调度，就是从**就绪队列中**按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的**并发**执行。

#### 4.1.2层次

##### 1）高级调度（作业调度）

> 是否创建进程

###### （1）定义

高级调度**即**在内存空间有限的条件下，按一定的原则**从外存上处于后备队列的作业**中挑选一个（或多个）作业，
为其分配内存等必要资源，并建立相应的进程（建立PCB），以使其**获得竞争处理机的权利**的过程

###### （2）涉及区域

辅存（外存）与内存之间的调度。

###### （3）特征

每个作业**只调入一次，调出一次**。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度**主要是指调入的问题**，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。

###### （4）状态转换

无->创建态->就绪态

##### 2）中级调度（内存调度）

> 是否结束进程挂起

###### （1）定义

- 挂起

  挂起**即**在虚拟内存存在的情况下，可将暂时不能运行的进程调至外存等待（**挂起态**）。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。目的是为了提高内存利用率和系统吞吐量

  **但是！**PCB并**不会**一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。**被挂起的进程PCB会被放到的挂起队列**

中级调度**即**决定将哪个处于挂起状态的进程**重新调入内存**。

###### （2）涉及区域

虚拟内存（外存）和内存

###### （3）特征

一个进程可能会被多次调出、调入内存，因此中级调度发生的**频率要比高级调度更高**

###### （4）状态转换

挂起态->就绪态

##### 3）低级调度（进程调度）

> 是否让已就绪的进程开始执行

###### （1）定义

是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。

###### （2）涉及区域

内存和CPU

###### （3）特征

进程调度是操作系统中**最基本**的一种调度，在一般的操作系统中都必须配置进程调度。

进程调度的**频率最高**，一般几十毫秒一次

###### （4）状态转换

就绪态->运行态

### 4.2进程调度时机与方法

#### 4.2.1调度时机

##### 1）可以调度的时机

- 主动放弃处理机
  - 进程正常终止
  - 运行过程中发生异常而终止
  - 进程主动请求阻塞（如等待I/O）
- 被动放弃处理机
  - 分给进程的时间片用完
  - 有更紧急的事需要处理（如I/O中断）
  - 有更高优先级的进程进入就绪队列（在优先级调度算法下）

##### 2）不可调度的时机

- 在**执行中断的过程中**：中断处理过程很复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换
- 进程**在操作系统内核程序临界区**中
- 在**执行原子操作过程中**（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）

> ***Q1***：**何为临界？**
>
> ***A1***：临界相关的有临界资源和临界区
>
> ​		  临界资源是指一个时间段内**只允许一个进程使用的资源**。各进程需要**互斥地访问**临界资源。
>
> ​		  临界区是指访问临界资源的那段代码
>
> ***Q2***：**处在临界区一定不能被调度吗？**
>
> ***A2***：**不一定**，在内核临界区时不可以，不在内核区时可以
>
> ​			 在访问就绪队列时，是处在内核临界区，如果没退出临界区（还没解锁）就进行进程调度，新的进程		 	会再次访问就绪队列，由于就绪队列未被解锁所以新的调度会被阻塞，这样会一直占用内核临界资源，			**影响操作系统内核**的工作
>
> ​			在进程调用打印机时，打印完成之前，进程一直处于临界区内，临界资源不会解锁，那么在打印期间的			这段时间中CPU被占用但是一直空闲，由于普通临界区访问的临界资源**不会直接影响操作系统内核**的管			理工作，因此在访问普通临界区时可以进行调度与切换

#### 4.2.2调度方式

##### 1）非剥夺调度方式

###### （1）定义

又称**非抢占**方式。即，**只允许进程主动放弃处理机**（不会被动放弃处理机）。在运行过程中即便有更高优先级的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。      

###### （2）特征

实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统

##### 2）剥夺调度方式

###### （1）定义

又称**抢占方式**。当一个进程正在处理机上执行时，如果有一个更高优先级的进程需要使用处理机，则**立即暂停**正在执行的进程，将处理机分配给更高优先级的那个进程。

###### （2）特征

剥夺调度方式可以实现两种调度功能

- 可以优先处理**更高优先级**的进程
- 实现让各进程按**时间片轮流**执行（通过时钟中断），适合于分时操作系统、实时操作系统

> ***Q***：**进程调度与进程切换的区别？**
>
> ***A***：狭义的**进程调度**指的是从就绪队列中选中一个要运行的进程，如果选中要执行的进程是其他进程，则需要进行**进程切换**，让当前进程让出处理机并分配给被选中进程
>
> ***注意：***进程切换是**有代价的**，因此如果**过于频繁的**进行进程调度、切换，必然会使整个系统的效率降低，
> 使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。

### 4.3调度算法

#### 4.3.1 评价指标

##### 1）CPU利用率


利用率 = 忙碌的时间/总时间


##### 2）系统吞吐量


系统吞吐量=完成的作业总数/完成消耗的总时间


##### 3）周转时间

###### （1）周转时间


周转时间=进程完成的时刻-作业提交到系统（被创建为进程）的时刻


周转时间包括如下几部分

- 作业在**外存后备队列上等待**作业调度（高级调度）的时间
- 进程在**就绪队列上等待**进程调度（低级调度）的时间
- 进程在**CPU上执行**的时间
- 进程**等待I/O操作完成**的时间

后三项在一个作业的整个处理过程中，可能发生多次。

> 操作系统更注重平均周转时间，这意味着总体的作业处理效率

###### （2）平均周转时间


平均周转时间=n个作业的周转时间之和/n


###### （3）带权周转时间


带权周转时间=作业周转时间/作业实际运行的时间=作业完成时间– 作业提交时间/作业实际运行的时间


###### （4）平均带权周转时间


平均带权周转时间=n个作业带权周转时间之和/n


`带权周转时间->1`，作业反馈越高效。可以通过提高作业实际运行时间或者压缩作业周转时间来达到

##### 4）等待时间


进程（作业）等待时间=进程（作业）处于等待处理机状态时间的总和


进程等待时间**包括**

- 进程建立后等待被服务的时间之和

**不包括**

- 在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间

作业等待时间**包括**

- 建立进程后的等待时间
- 作业在外存后备队列中等待的时间

>调度算法其实只会影响作业/进程的等待时间，因为IO处理时间一般是不变的

##### 5）响应时间


响应时间=进程首次被响应的时刻-作业被提交到系统的时刻


#### 4.3.2 批处理操作系统

> 本部分的三种算法**均不考虑响应时间**，**只考虑平均周转时间、等待时间**，每一个作业也不存在优先级
>
> 本节图片均来自**王道考研**

##### 1）先来先服务（First Come First Serve）

> 非抢占+不会饥饿（某作业长期得不到服务）		对长作业有利

###### （1）定义

所有的作业进入一个FIFO队列，并按照FIFO的规则被调入CPU执行

###### （2）示例

![image-20201028202926698](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201028202926698.png)

###### （3）适用对象

用于作业调度时，考虑的是哪个作业先到达后备队列

用于进程调度时，考虑的是哪个进程先到达就绪队列

###### （4）优缺点

- 优

  公平、算法实现简单

- 缺

  排在长作业（进程）后面的短作业需要等待很长时间，**带权周转时间很大**，对短作业来说用户体验不好。即，
  FCFS算法**对长作业有利，对短作业不利**

##### 2）短作业优先

> 默认是指非抢占式 			对短作业有利

##### :one: 非抢占式（Shortest Job First）

###### （1）定义

**每次在没有进程运行时**，查看当前就绪队列中进程要求的执行时间，**递增**排序，选出运行时间最小的放入CPU执行

###### （2）示例

![image-20201028204027402](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201028204027402.png)

###### （3）特性

在所有进程**都几乎同时到达**时，采用SJF调度算法的平均等待时间、平均周转时间最少

###### （4）优缺点

- 优

  “最短的”平均等待时间、平均周转时间

- 缺

  **对短作业有利，对长作业不利**。可能产生饥饿现象

##### :two: 抢占式（Shortest Remaining Time Next）

###### （1）定义

**在每个时刻**，检查**当前运行的进程和就绪队列中的剩余运行时间**（对于刚插入就绪队列的，即为运行时间），递增排序，选出**剩余运行时间最短**的放入CPU执行

###### （2）示例

![image-20201028204452580](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201028204452580.png)

###### （3）特性

如果进程是分批到达时，采用SRTN调度算法的平均等待时间、平均周转时间最少

###### （4）优缺点

- 优

  “最短的”平均等待时间、平均周转时间

- 缺

  **对短作业有利，对长作业不利**。可能产生饥饿现象

##### 3）高响应比优先（HRRN）

>非抢占式+不会饥饿  		综合考虑作业/进程的等待时间和要求服务的时间

###### （1）定义

在每次调度时先计算各个作业/进程的响应比，选择**响应比最高**的作业/进程为其服务，响应比计算公式如下

响应比=等待时间+要求服务时间/要求服务时间（响应比≥ 1）


###### （2）示例

![image-20201028225117877](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201028225117877.png)

###### （3）特性

非抢占式的算法。因此只有当前运行的作业/进程**主动放弃处理机时，才需要调度**，才需要计算响应比

###### （4）优缺点

综合考虑了等待时间和运行时间（要求服务时间）

- 优

  - 等待时间相同时，要求服务时间短的优先（SJF 的优点）
  - 剩余运行时间相同时，等待时间长的优先（FCFS 的优点）

  对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题


#### 4.3.3 交互式操作系统

##### 1）轮转调度（Round-Robin）

###### （1）定义

按照各个进程**到达就绪队列的顺序**，**轮流的**让各个进程执行**一个时间片**，如果进程**已耗尽一个时间片且未执行完**，则剥夺处理机使用权，将进程PCB重新放入**就绪队列**的**队尾**

要遵循下面两个规则

- 当发生调度时如果有新进程来，那么默认让新进程先插入到队尾，之后再将刚刚耗尽时间片且未执行完的进程放入队尾
- 如果一个进程在时间片未耗尽前执行完成并下处理机，那么会发生一次调度，队头的进程会获得一个完整的时间片来执行

###### （2）示例

:one: 时间片为2

![image-20201029201057804](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201029201057804.png)

![image-20201029200855092](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201029200953935.png)

![image-20201029201119460](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201029201119460.png)

:two: 时间片为5

![image-20201029201715941](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201029201715941.png)

###### （3）特性

- 适用于进程调度

  因为只有作业被创建为进程能分配时间片（或者说只有进程才可能处在就绪队列上）

- 抢占式

  在时间片被耗尽时，进程会被剥夺CPU使用权

- 时间片长度选择

  - 太大

    如果太大，则会退化为FCFS算法

  - 太小

    如果太小，会导致进程频繁切换，带来过多的切换开销

- 时间片耗尽提醒

  通过时钟终端来提醒时间片耗尽

- 饥饿

  每个进程都会被分到时间片，不会导致饥饿

###### （4）优缺点

- 优
  - 公平，响应快
  - 适用于分时操作系统
- 缺
  - 频繁的进程切换
  - 不存在优先级

##### 2）优先级调度算法

###### （1）定义

每个进程/作业都有自己的优先级，调度时选择优先级最高的进行调度

###### （2）示例

##### :one: 非抢占式

![image-20201029202519069](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201029202519069.png)

:two: 抢占式

![image-20201029202748782](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201029202748782.png)

###### （3）特性

- 抢占式/非抢占

  - 抢占式

    在进程未执行完就可以调度

  - 非抢占

    在进程未执行完不可以调度

- 适用对象

  适用于作业、进程、IO调度

- 优先级设定

  - 动态优先级

    可以适当提高等待时间较长的进程的优先级来让其可以被调度

  - 静态优先级

    提前指定好优先级规则且不可以改变

  - 默认规则

    - 系统级进程>用户级进程
    - 前台进程>后台进程
    - 更偏向于IO型进程

- 饥饿

  可能会导致饥饿

###### （4）优缺点

- 优

  适用于实时操作系统，灵活的对不同优先级的进程调度

- 缺

  如果一直有更高优先级的进程到来，那么就绪队列中的进程可能会饥饿

##### 3）多级反馈队列算法（UNIX中使用）

###### （1）定义

设置多级就绪队列，优先级越低越靠下，队列中每个进程可获得的时间片越长

进程按如下规则放入不同级队列进行调度

- 新进程会被放入第一级队列，按照FCFS规则调度，当该级别队列赋予的时间片耗尽但进程还未结束时，调度到下一级队列的队尾，如果此时已经是最低级队列，则放入该级队尾
- 只有高级队列为空时才会调度低级队列
- 只要有更高级别的队列有进程要放入（不论是新进程抵达第1级队列还是第1级队列的执行完下放到第2级队列），都会先调度更高级别的进程，剥夺当前运行进程的CPU使用权使其回到当前队列队尾并让处在更高级别的进程获得时间片

###### （2）示例

![image-20201029205059538](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201029205059538.png)

0时刻，P1放入第1级队列，执行一个时间片

1时刻，P1时间片耗尽，放入第2级队尾；同时P2到达，执行一个时间片

2时刻，P2时间片耗尽，放入第2级队尾；P1在第二级别队头，获得两个时间片

4时刻，P1时间片耗尽，放入第3级队尾；P2在第二级别队头，获得两个时间片

5时刻，P2未执行完，但是新进程P3到达，P2被剥夺，被放入第2级队尾；同时P3获得一个时间片

6时刻，P3时间片耗尽且执行完，下处理机，这时第1级队列为空，第2级队列不为空，P2获得两个时间片

7时刻，P2时间片耗尽且执行完，下处理机，这时第2级队列为空，第3级队列不为空，P1获得四个时间片

11时刻，P1时间片耗尽，第1级和第2级队列为空，且P1处在第3级队头，被调度，获得4个时间片

12时刻，P1执行完且时间片未耗尽，下处理机

###### （3）特性

- 适用对象

  适用于进程调度

- 抢占式

  如果处在第k级队列的进程正在执行，此时1~k-1级进入一个新进程，那么会立刻剥夺当前进程的CPU使用权，并将其调度到当前优先级队列的队尾，并分配时间片给更高级队列中的进程

###### （4）优缺点

- 优

  - 每个队列中的进程按FCFS执行，较为公平
  - 新到达的进程会立即被调度，具有RR的特性（RR是新进程尽快被调度）
  - 由于越高级队列时间片越短，所以时间片短的进程会尽快被执行完，具备SJF特点
  - 不必预估各进程的消耗时间
  - 可以通过"后门"，让IO密集型的进程一直处在较高优先级的队列中

- 缺

  如果一直进入新进程，处在最低优先级的长进程会饥饿
