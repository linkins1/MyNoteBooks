## 2.进程

### 2.1 基本概念

#### 2.1.1 定义

进程即一个正在执行的程序的实例（或进程实体或进程上下文环境或进程映像），包括程序计数器、寄存器和变量的当前值。

进程是系统进行资源分配和调度的**独立单位**

#### 2.1.2 进程实体的组成

##### 1）PCB（进程存在的唯一标志）

###### （1）程序描述的信息

:one: 进程标识符PID

:two: 用户标识符UID

###### （2）进程控制和管理信息

:one: CPU、磁盘、网络流量等使用的统计

:two: 进程当前的状态

###### （3）资源分配清单

:one: 正在使用哪些文件

:two: 正在使用哪些内存区域

:three: 正在使用哪些IO设备

###### （4）处理机相关信息

程序计数器等寄存器的值

##### 2）程序段

程序代码

##### 3）数据段

使用的变量

#### 2.1.4 分类

##### 1）守护进程（daemon）

停留在后台，在发生特定请求时被唤醒并执行的进程，如打印、发送email等

##### 2）前台进程

用户可以感知到的进程

#### 2.1.5 特征

##### 1）动态性（最基本的特征）

进程是程序的一次执行过程，是动态的产生变化和消亡的

##### 2）并发性

**内存中**的多个进程实体是并发执行的

##### 3）独立性

进程是系统进行资源分配、调度的独立单位

##### 4）异步性

由并发性带来的，在不同的同步机制下，每个进程实体将动态的执行

##### 5）结构性

每个进程都有一个PCB

#### 2.1.6 组织

多个进程间的组织方式可以分为如下两类

##### 1）链接方式

按照进程的状态将**PCB**分为多个**队列**，操作系统持有各个**队列的指针**，如下图所示（摘自王道考研）

<img src="C:%5CUsers%5C123%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201022203510982.png" alt="image-20201022203510982" style="zoom: 67%;" />

##### 2）索引方式

按照进程的**状态分类**后分别创建**索引表**，操作系统持有各个**索引表的指针**，如下图所示（摘自王道考研）

<img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201022203636906.png" alt="image-20201022203636906" style="zoom: 67%;" />

### 2.2 进程间通信

由于每个进程**拥有独立的内存地址空间**，为了保证**安全**，**不允许**一个进程**直接访问**另一个进程**独有的内存**，那么进程间想实现通信要解决两个问题

- 如何将一个进程的消息传递给另一个（**如何共享**信息）
- 如何确保进程间通信在关键活动时不会交叉运行（**如何安全的共享**）

> 本节主要介绍**共享的方式**，安全的**共享策略放在进程调度介绍**

#### 2.2.1 共享存储

##### 1）定义

<img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201022205237447.png" alt="image-20201022205237447" style="zoom:67%;" />

如上图所示，可以在内存空间中划分出一块区域作为共享区域，进程1和2都可以直接访问这块内存进行信息共享。

为了保证安全的访问这块内存，1和2必须**互斥的**进行访问

##### 2）共享存储分类

###### （1）基于存储区（高级、高效）

如C语言中使用malloc或calloc函数，即可从内存中申请一片内存区域出来，进程可以向内存中写入任意数据（以字节流形式），进程申请到的内存必须负责释放。

###### （2）基于数据结构（低级、低效）

如在程序中定义一个数组或链表来进行共享，这样会受制于数据结构的类型，不够灵活，共享效率差

#### 2.2.2消息传递

##### 1）直接通信

<img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201022210708951.png" alt="image-20201022210708951" style="zoom:80%;" />

如上图所示，两个进程直接对消息缓冲队列进行存取

##### 2）间接通信

![image-20201022211459648](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201022211459648.png)

间接通信如上所示，进程1和2**都不直接**对消息队列进行操作，进程1（生产者）只负责发送给中间件，由中间件中配置的信息（如订阅发布信息）将消息转发给进程2（消费者），实现进程间的间接通信。上图给出的是类似于rabbitmq的工作机制

#### 2.2.3管道

##### 1）定义

管道是用于**连接读写进程的一个共享文件**，又名**pipe文件**。其实就是在内存中开辟**一个大小固定的缓冲区**

通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写	

管道可以用于单个进程中，即进程中从管道一方写入，一方读出

管道可以用于父子进程或兄弟进程，父子进程都通过管道一方写入，从管道另一方读出

```c
#include <unistd.h>
int pipe(int fd[2]);
```

![img](https://camo.githubusercontent.com/ea23bf43dfe705c9b9c1016389993e609b50a1ee/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35336364396164652d623061362d343339392d623464652d3766316662643036636466622e706e67)

##### 2）特征

- 管道只能采用**半双工**通信，某一时间段内只能实现**单向的传输**。如果要实现双向同时通信，则需要设置
  两个管道。
- 只能在**父进程相关的进程**中使用
- 各进程要**互斥**地访问管道。
- 数据以**字符流**的形式写入管道，**当管道写满时**，**写进程**的write()系统调用将**被阻塞**，等待读进程将数据
  取走。当读进程将数据**全部取走后**，管道变空，此时**读进程**的read()系统调用将**被阻塞**。
- 如果**没写满，就不允许读**。如果**没读空，就不允许写**。
- 数据**一旦被读出，就从管道中被抛弃**，这就意味着**读进程最多只能有一个**，否则可能会有读错数据的情
  况。

从上面可以看出，管道只有两种状态，**全空**和**全满**

#### 2.2.4 FIFO（命名管道）

##### 1）定义

FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。

##### 2）特征

- **命名管道是一个设备文件**，其**打破了**只能在父进程相关进程中使用的规则。
- 同样是半双工，支持先进先出

![img](https://camo.githubusercontent.com/5655a545eb67ea75889b546efe007fffb2483885/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32616335306238312d643932612d343430312d623965632d6632313133656363333037362e706e67)

#### 2.2.5 信号量

是某个资源的计数器，为多个进程访问提供了剩余标准

#### 2.2.6 socket

通过建立TCP连接来通信，支持不同主机和本地环回的通信

### 2.3 进程控制

#### 2.3.1 进程的状态转换图

<img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20201024212027063.png" alt="image-20201024212027063" style="zoom: 50%;" />

**触发上图中进程状态转换的`动作`即为进程控制**

> ***Q***：**挂起和阻塞的区别**
>
> ***A***：两种状态都会被剥夺CPU使用权，但是挂起进程实体会被调到外存中，阻塞进程实体仍然在内存中

#### 2.3.2 进程控制手段

##### 原语

###### （1）定义

原语（又称原子操作）是操作系统内核的一个功能，是一种特殊的程序，具备**不能被中断的特性**。

###### （2）实现

用“关中断指令”和“开中断指令”这两个特权指令实现原子性。

当执行关中断指令之后，操作系统就不再接受终端请求，直到执行开中断指令，这样这两个指令之间的内容就实现了原子性

###### （3）进程相关的原语

- 创建原语

  这个原语会执行如下几样操作

  - 申请空PCB
  - 为新进程初始化资源
  - 初始化PCB
  - 将PCB插入就绪队列（`创建态->就绪态`）

  创建进程的事件有如下几个

  - 用户登录

    linux中每登入一个新用户，就会创建一个新的进程，表现为一个新终端

  - 作业调度

    当有新的作业被调度到时，会先创建其对应的进程

  - 提供服务

    如用户执行一个程序，会创建新进程

  - 应用请求

    如进程内执行fork，会创建一个新的子进程

- 撤消原语（`运行态->终止态`）

  撤消原语会执行如下几样操作

  - 从PCB集合中找到要撤销的进程的PCB
  - 如果进程在运行中，则立刻令其停止，剥夺其CPU使用权
  - 终止其所有子进程
  - 将进程资源归还给操作系统
  - 删除PCB

  引起进程终止的事件有如下

  - 正常结束

    进程正常执行完成，调用exit退出

  - 异常结束

    执行中出现运行时异常，抛出异常并主动停止

  - 外部中断

    用户手动杀死进程，如kill -9操作

- 阻塞原语（`运行态->阻塞态`）

  阻塞原语会执行如下几样操作

  - 找到要阻塞的PCB
  - 记录进程当前状态，设定PCB中的状态为阻塞态，暂时停止进程运行
  - 将PCB插入相应事件的阻塞队列

  引起进程阻塞的事件有如下

  - 进程在申请资源时失败，主动进入阻塞状态
  - 系统资源耗尽，被调度进阻塞队列

- 唤醒原语（`阻塞态->运行态`）

  唤醒原语会执行如下几样操作

  - 在阻塞队列中找到对应的PCB
  - 将PCB从阻塞队列移除，放入就绪队列并设定进程状态为就绪态

  引起进程唤醒的事件有如下

  - 等待的系统资源被分配
  - 由其他进程唤醒

- 切换原语（`运行态<->就绪态`）

  切换原语会执行如下几样操作

  - 将**运行环境**信息（程序计数器、程序状态字、各种数据寄存器等处理机现场信息）存入PCB
  - 将PCB移入对应的队列
  - 调度另一个进程开始执行，并根据其PCB**恢复**进程**运行环境**

  引起进程切换的事件有如下

  - 时间片被耗尽
  - 更高优先级抢占（在抢占式调度下）
  - 当前进程主动阻塞
  - 当前进程终止，调度另一个进程执行

- **总结**
  - 更新PCB中的信息
    - 所有的进程控制原语一定都会修改进程状态标志
    - 剥夺当前运行进程的CPU使用权必然需要保存其运行环境
    - 某进程开始运行前必然要恢复期运行环境
  - 将PCB插入合适的队列
  - 分配或回收

### 2.4 父子进程

#### 2.4.1 0/1/2号进程

Linux中的所有进程都是由0号进程 -idle `fork`出来的，idle进程运行于内核态，其会创建出1号进程和2号进程

1号进程(init)是由kernel_thread创建的，其在内核空间完成初始化，之后运行于用户态，是其他用户进程的父进程，完成创建之后会以守护进程的方式监控用户进程

2号进程(kthreadd)由kernel_thread创建的，其运行于内核态，负责所有内核级线程的管理和调度

<img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/temp/image-20210329132147274.png" alt="image-20201024212027063" style="zoom: 50%;" />

#### 2.4.2 fork

##### 1）原理

fork函数用于创建子进程，采用写时复制的方式创建，效果等同于快照，有如下特点

- 是一个单独的进程
- 子进程的堆、栈、PCB（包括打开文件描述符等）都是父进程的当前副本，也即不和父进程共享，但是文件偏移量是会被共享的

> 参考linux manpage，可以发现不复制的条目有如下
>
> - 子进程用于独立且唯一的进程 ID；
> - 子进程的父进程 ID 与父进程 ID 完全相同；
> - 子进程不会继承父进程的内存锁；
> - 子进程会重新设置进程资源利用率和 CPU 计时器；
> - …


- 子进程创建后一般会被先执行

  子进程被创建后会从fork函数开始执行

- 第一次调用

  以子进程的身份调用，返回值为0，以父进程身份调用返回子进程pid

- 后续调用

  以独立进程的身份调用，会触发子子进程的创建

##### 2）示例

> 代码来源[神奇的fork（父子进程中一些神奇的问题） - 简书 (jianshu.com)](https://www.jianshu.com/p/0ec862d282d1)

```cpp
int main()
{
       pid_t cld_pid;
       int status;
       int a=1,b=2;
       for(int i = 0; i < 2; i++ ){
              if ((cld_pid = fork()) == 0){
                     a+=1;
                     printf("a=%d\n",a);
              }
              else{
                     b+=1;
                     printf("b=%d\n",b);
              }
       }
       wait(&status);
       return 0;
}
```

上面代码流程如下

- 父进程fork，产生子进程1

  此时a=1，b=2，i=0

  - 子进程1

    - 第一次fork

      返回0，a+=1变为2，输出a=2，i++

    - 第二次fork创建子子进程1-1

      此时a=2，b=2，i=1

      - 子子进程1-1

        调用fork返回0，a+=1变为3，输出3，i++后>=2，返回

      子进程1fork的返回值为子子进程1-1的pid，进入else，b+=1变为3，输出b=3，i++后>=2返回

  父进程fork返回值为子进程1的pid，b+=1变为3，输出b=3，i++

- 父进程再次fork，产生子进程2

  此时a=1，b=3，i=1

  - 子进程2

    调用fork返回0，a+=1变为2，输出a=2，i++后>=2，返回

  父进程fork返回值为子进程2的pid，进入else，b+=1变为3，输出b=4，i++后>=2返回

综上所述，一共创建了3个进程，进程树如下

- 父进程
  - 子进程1
    - 子进程1-1
  - 子进程2

##### 3）写时复制

###### （1）虚拟内存

- 大小

  在一台64位的机器上，理论上有 256 TiB 的寻址空间，由于内核区要占用一部分空间，因而实际情况下，用户空间只占用了64位中的57位/48位

- 独立性

  对于每个进程来说，都有独立的完整的用户区的虚拟内存寻址空间

###### （2）策略

- 创建复制

  fork之后，子进程会复制父进程的页表内容（虚拟/逻辑地址相同），并将页表对应内存设为**只读**，这时，父子的页表是独立的，其中内容（物理地址）完全一致。

  > 假设程序段中有一局部变量为x，则打印x的（逻辑）地址会发现是一致的

- 写时复制

  在没有对内存中的数据进行修改时，父子进程中的页表将保持原样，当发生修改时，修改的一方会复制内容并创建一条新记录，对应着新的物理地址和逻辑（虚拟）地址，并将原地址和新地址对应的内存权限修改为**可读写**，也即此时父子进程此时页表中存储的虚拟地址不同，且映射的物理地址也不同。

> redis的bgsave输出rdb文件使用了fork的写时复制的特性，具体参考[为什么 Linux 需要虚拟内存 - 面向信仰编程](https://draveness.me/whys-the-design-os-virtual-memory/#fn:5)
>
> 写时复制图片参考[Linux 写时复制机制原理 - SegmentFault 思否](https://segmentfault.com/a/1190000039869422)

