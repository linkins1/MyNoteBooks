## 8.文件管理

### 8.1 基本概念

#### 8.1.1 文件

##### 1）属性

- 文件名：对用户有可读性，用户用来查找文件使用
- 标识符：对用户没有可读性，操作系统用于唯一确定一个文件
- 类型
- 位置
- 大小
- 创建时间
- 所有者信息
- 保护信息

##### 2）组织方式

- 无结构文件：二进制字符流
- 有结构文件：一组相关数据项的集合，类似于表格

##### 3）系统调用

为了方便用户操作文件，操作系统给出如下系统调用

- 创建文件-create
- 删除文件-delete
- 读文件-read
- 写文件-write
- 打开文件-open
- 关闭文件-close

> 读写文件之前要打开文件，完成后要关闭文件

##### 4）存储方式

将外存划分为一个个块，文件可以连续、离散的存储在外存中

#### 8.1.2 文件管理方式

##### 1）文件逻辑结构

文件内部的数据应当如何被组织起来

##### 2）目录结构

文件之间应当如何被组织起来

##### 3）文件物理结构

文件如何存放于外存中

##### 4）存储空间管理

操作系统如何管理外存中的文件块

> 文件的物理结构和逻辑结构类似于数据结构的物理存储方式和逻辑抽象形式

### 8.2 文件逻辑结构

#### 8.2.1 无结构文件

一系列的二进制流或字符流，称作“流式文件”，比如.txt文件

#### 8.2.2 有结构文件

称为记录式文件，每条记录由多个数据项组合而成，根据记录的长度是否可变分为**定长记录**和**可变长记录**

##### 1）顺序文件

文件的记录是一个一个顺序的排列的，记录长度可变

-  串结构

  记录之间的顺序和关键字无关

- 顺序结构

  记录之间的顺序按关键字顺序排列

此结构**在物理上**可以使用

- 顺序存储

  - 可变长记录时，无法实现随机访问
  - 定长记录时，可以实现随机访问

- 链式存储

  无论记录长度是否可变，都无法实现随机访问

##### 2）索引文件

通过建立如下索引表，这样在每次访问某个索引的数据时，可以通过索引表中存储的指针直接访问对应的数据

<img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210221161649376.png" alt="image-20210221161649376" style="zoom: 67%;" />

由于索引表中的每条表项长度是固定的，那么使用索引表的方式可以解决存储的变长记录时，也能通过索引表实现快速访问的目的

##### 3）索引顺序文件

为了解决索引表过大的问题，可以将索引表中的数据进行分组，并**将每个分组的头顺序排放**构成一个新的高一级的索引表，如果一次分组后，索引表仍然很大，那么就对新的索引表继续分组，再构成更高一级的索引表，这样就构成了多级索引顺序文件

### 8.3 文件目录

#### 8.3.1 文件控制块（File Control Block）

##### 1）概念

一个FCB是一个文件目录项，其包含**文件名、物理地址**、逻辑结构、物理结构、类型、存储权限等信息，一个目录下的所有FCB以表格的形式存储

##### 2）操作

- 搜索

  根据文件名搜索对应的目录项

- 创建

  在FCB表中新添一个FCB

- 删除

  在FCB表中删除一个FCB

- 修改

- 显示

##### 3）改进

由于在根据文件名遍历FCB表时，只需要文件名这一个属性，为了减少引入内存的FCB表的大小，可以将除了文件名的属性存放到磁盘中构成一个**索引节点**，并在FCB中保留指向这个索引节点的指针

这样减少了FCB的大小，可以使得每个磁盘块存有更多数量的FCB，**从而减少磁盘IO的次数**

#### 8.3.2 目录结构

##### 1）单级目录结构

不允许文件重名，所有的文件存储于一个目录下

##### 2）两级目录结构

采用两级目录结构，分为主文件目录和用户文件目录

主文件目录存储用户对应的FCB，用户文件目录存储多个文件对应的FCB

这样不同用户目录下的文件可以重名

##### 3）多级目录结构（树形目录结构）

采用多级目录结构，为了更高效的访问目录，衍生出

- 相对路径

  相对于某一目录的路径

- 绝对路径

  从根目录开始的路径

##### 4）无环图目录结构

目录结构为有向无环图，可以让多个目录节点指向同一个文件，这样就避免了树形目录结构带来的冗余拷贝的问题

为了适应多个目录节点指向同一个文件的特性，需要维护一个共享计数器，在没有任何目录引用此文件时才删除文件

### 8.4 文件物理结构（文件在磁盘中的分配方式）

> 需要考虑对非空闲磁盘块的管理

- 磁盘块

  磁盘的多个存储单元会被划分为一个磁盘块，整个磁盘空间会被划分成多个磁盘块

- 文件块

  文件占用的逻辑地址空间（如文件大小为1024B，那么逻辑地址为0-1024）会被划分为多个块，这样唯一确定一个逻辑地址时就需要**逻辑块号+块内偏移量**来确定

#### 8.4.1 连续分配

- 机制

  即在磁盘上占用一组连续的磁盘块

- 地址转换

  FCB中存储了每个文件项的**物理起始块号**和**文件块长度**，由于是连续分配，所以要访问的逻辑块号对应的

  物理块号=起始块号+逻辑块号

- 特性

  - 优点
    - 支持顺序访问和随机访问
    - 读写速度块，这归因于磁盘读写时需要移动磁头
  - 缺点
    - 不便于实现文件扩展
    - 会产生大量的文件碎片
    - 存储空间利用率低

#### 8.4.2 链接分配

分配离散的磁盘块

##### 1）隐式链接

- 机制

  需要在FCB中记录起始块号和终止块号，且除了最后一个磁盘块的每个磁盘块都会存储指向下一个磁盘块的指针

- 特性

  - 缺点
    - 每个磁盘块都需要浪费一小块空间来存放下一个盘块的指针
    - 只支持顺序访问不支持随机访问
  - 优点
    - 无内存碎片
    - 磁盘存储空间利用率高
    - 方便文件扩展

##### 2）显式链接

- 机制

  需要在FCB中存储起始块号，并将每个物理块号指向的下一个块的指针连同物理块号存储文件分配表（File Allocate Table）中，相对于隐式链接，其区别在于将原来在磁盘块中存储的下一块指针全部抽取出放入FAT中

  为了加快磁盘块访问，FAT通常常驻内存，这样可以避免磁盘IO

- 特性

  - 优点

    - 不会产生外部碎片
    - 文件可扩展性强

  - 缺点

    FAT需要占用内存空间

#### 8.4.3 索引分配

##### 1）机制

允许文件分配于离散的磁盘块中，系统**为每个文件**建立一张**索引表**，其中记录了文件的各个逻辑块对应的物理块

由于索引表也需要存放在磁盘中，因而用于存放索引表的磁盘块为索引块，用于存储文件数据的块为数据块

##### 2）特性

- 优点
  - 支持随机访问
  - 文件易于扩展
- 缺点
  - 需要占用一部分磁盘存储索引表
  - 当一个磁盘块放不下整张索引表时，会引起性能损耗

##### 3）改进

- 链接

  将索引表拆分后分别存放在不同的磁盘块中，并让每个索引表最后一个表项存储存储指向下一个索引表所在磁盘块的指针

  之后将第一个索引表的磁盘块存储FCB

- 多层索引

  建立多层索引，将索引进行分组，每组的大小不超过一个磁盘块，并构建为一个新的索引表，如果新的索引表大小仍然超过一个磁盘块，那么就继续分组直至每级的各个索引表大小均小于等于一个磁盘块大小

  之后将顶级索引表的磁盘块存储FCB

- 混合索引

  让顶级索引表中既存储直接索引，也存储下面几级索引表的地址，如下所示

  ![image-20210221185208711](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210221185208711.png)

  这样就解决了使用多层索引时，访问小文件也需要多次磁盘IO的开销

### 8.5 文件存储空间管理

> 需要考虑对空闲磁盘块的管理

#### 8.5.1 存储空间的划分

将物理磁盘空间划分为一个个逻辑卷，每个逻辑卷包含目录区和文件区，如下图所示

![image-20210222120117672](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-2021022212011761272.png)

#### 8.5.2 存储空间管理

##### 1）空闲表法

- 机制

  ![image-20210222120547302](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210222120547302.png)

  此方式适用于连续分配方式

- 回收

  回收内存时，需要根据被回收区域前后的状况来决定是否需要合并记录或者增加记录

##### 2）空闲链表法

###### （1）空闲盘块链

![image-20210222120855766](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210222120855766.png)

###### （2）空闲盘区链

![image-20210222121009961](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210222121009961.png)

##### 3）位示图法

![image-20210222121420536](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210222121420536.png)

<img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-2021022212150711122.png" alt="image-20210222121507112" style="zoom:67%;" />

##### 4）成组链接法（UNIX中的策略）

- 机制

  为了解决空闲表/空闲链表过大的情况，通过分组重建的方式可以减少需要维护的存储信息

  成组链接法需要如下条件

  - 需要一个超级块来存储下一个分组的空闲块号
  - 每组空闲块数量有上限
  - 每个组的第一个空闲块需要存储再下一组的空闲块号
  - 每次分配空闲块时，从超级块尾端开始遍历，分配最后一个空闲块
  - 每次回收空闲块时，也从超级块检索，如果超级块未满，则插入超级块中；否则创建新的分组

  超级块会被读入内存，且在超级块发生修改时，内存中的信息也需要进行相应的修改

- 示例

  ![image-20210222124314246](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210222124314246.png)

  - 分配内存

    - 分配1个空闲块

      超级块中有100个空闲块，将201号空闲块分配出，并删除201记录，将100改为99

    - 分配100个空闲块

      将300号块中存储的分组信息存入超级块（覆盖），将100改为100

  - 回收内存

    - 超级块没满

      将记录插入超级块尾端

    - 超级块已满

      将超级块中的记录复制入下一组的第一个空闲块，并清空超级块，之后写入下一组空闲块的记录

  ### 8.6 文件的基本操作

  #### 8.6.1 创建

  <img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210222125308156.png" alt="image-20210222125308156" style="zoom:67%;" /> 

  #### 8.6.2 删除

  <img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210222125538183.png" alt="image-20210222125538183" style="zoom:67%;" /> 

  #### 8.6.3 读

  ![image-20210222130354666](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210222130354666.png)

  #### 8.6.4 写

  ![image-20210222130503987](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-2021022213050391287.png)

  #### 8.6.5 打开

  ![image-20210222125720847](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210222125720847.png)

  ![image-20210222125824334](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210222125824334.png)

  #### 8.6.6 关闭

![image-20210222125903293](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210222125903293.png)

### 8.6 文件共享

#### 8.6.1 基于索引节点（硬链接）

也即在**不同的FCB中将**索引节点的指针**记为同一个文件的物理地址**，这样就额外需要计数值来记录有多少FCB引用此文件，在计数值为0时，即可删除文件

#### 8.6.2 基于符号链（软链接）

也即把一个FCB的索引节点指针存储为一个**LINK类型的文件**，此LINK文件会存储**要共享的文件的FCB的路径**，这样便**引用到了**要共享的文件

> 对比图
>
> ![image-20210222132049487](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210222132049487.png)
>
> User1和User2采用硬链接方式，User3采用软链接，LINK文件存储的User1中的FCB的路径

在删除共享文件时，LINK文件不会被删除，因而会出现使用软链接访问共享文件遇到文件被删除的情况

### 8.7 文件保护

#### 8.7.1 口令

![image-20210222132521784](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210222132521784.png)

#### 8.7.2 加密

![image-20210222132614184](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210222132614184.png)

安全性高，时间复杂度高

#### 8.7.3 访问控制

![image-20210222132641010](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210222132641010.png)

实现灵活，可以配置多种不同的文件保护方式

### 8.8 文件系统的层次结构

![image-20210222133253979](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/os/image-20210222133253979.png)

- 用户接口

  系统调用

- 文件目录系统

  维护文件打开表，找到对应FCB

- 存取控制模块

  安全性验证

- 逻辑文件系统与文件信息缓冲区

  将要访问的文件的索引/记录转换为逻辑地址

- 物理文件系统

  将逻辑地址转换为物理地址