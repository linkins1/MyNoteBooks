## 3. 线程

### 3.1 基本概念

#### 3.1.1 定义

线程是**轻量级的**进程，是一个基本的CPU执行单元（处理机**调度的基本单位**），也是程序执行流的最小单位。

**需要注意！**进程仍然是资源分配的单位，进程中的线程共享所属进程的资源

> ***Q：*****所有系统资源都是以进程为单位进行分配的吗？**
>
> ***A：***不是，CPU执行权是以线程为单位进行分配的

#### 3.1.2特性

##### 1）并发

可以使用类似于多进程的方式，多个线程也可以并发的执行

##### 2）共享进程资源

属于同一个进程的多个线程共享进程中的资源（如进程中的变量），这也使得进行线程切换的开销要小于进程切换

##### 3）独有的资源

每个线程都有单独的程序计数器和局部变量表

##### 4）主线程

每一个进程至少拥有一个线程即主线程

#### 3.1.3分类

##### 1）用户级线程（协程）

###### （1）定义

即在用户空间（用户进程内）创建的线程，不需要内核支持，它的内核的切换是由用户态程序自己控制内核的切换，不需要内核的干涉。但是它不能像内核级线程一样更好的运用多核CPU。

###### （2）特性

- 调度单位

  在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行

- 实现

  可以在不支持线程的操作系统中实现

- 阻塞

  同一进程中只能同时有一个线程(多对一时)在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起，可以节约更多的系统资源

##### 2）内核级线程

###### （1）定义

即在用户态运行、由操作系统内核负责切换调度的线程

###### （2）特性

- 调度

  在内核支持线程的系统内，CPU调度则**以内核级线程为单位**，在进行线程切换调度时需要从用户态切换到内核态，调度完毕后从内核态转换到用户态运行

- 并行

  当有多个处理机时，一个进程的多个线程可以并行执行

##### 3）用户级线程与内核级线程映射

###### （1）定义

在同时支持内核级和用户级线程的系统中，可以按不同规则将用户级线程映射到内核级线程上

###### （2）映射规则

- 多对一

  多个用户级线程映射到一个内核级线程

  - 优缺点

    - 优

      用户级线程的切换在用户态可以完成

    - 缺

      一个用户级线程阻塞后，整个进程都会被阻塞，多个线程不可在多核处理器上并行执行

- 一对一

  一个用户级线程映射到一个内核级线程

  - 优缺点

    - 优

      当一个用户级线程阻塞，其他线程仍可运行

    - 缺

      一个用户进程会占用多个内核级线程，线程切换需要在核心态下完成

- 多对多

  将n个用户级线程映射到m个内核级线程上，假设有3个用户级线程，2个内核级线程，那么在进行线程切换时，由于要在内核态完成，就必定有两个用户级线程会共同映射到一个内核级别线程上。同时最多也只有两个内核级线共同执行

  - 特性
    - 解决了多对一并发度不高的问题
    - 解决了一对一系统资源占用过多的问题

>***Q1：*****操作系统可以负责管理用户级线程吗？**
>
>***A2：***不负责，操作系统只管理内核级线程，也正因如此，**CPU的执行权是按照内核级线程为单位进行分配的**
>
>***Q2：*****更多的CPU核心数（逻辑核心数）意味着更多的内核级线程吗？**
>
>***A2：***不是，内核级线程的个数受限于操作系统支持的数量

### 3.2 线程调度

根据操作系统支持的线程级别不同（用户级线程或内核级线程），采用类似于进程调度的算法对线程进行调度

### 3.3 协程

#### 3.3.1 co-routine

**协程**也称**用户态线程**，是运行在**用户态**的轻量级的线程，多个协程会在同一个线程中交替执行，每个协程拥有单独的寄存器和程序计数器

由于线程是CPU调度的基本单位，且多个协程运行在一个线程中，因而**不存在内存可见性**的问题，因为同在一个CPU上，此外也不需要锁的机制，因为多个协程是互斥的在线程中执行的，所以对共享变量的修改**不存在竞争问题**

由于协程的寄存器和程序计数器均处于用户态，其调度由用户来决定，因而相较于线程有如下额外特征

- 对CPU透明
- 寄存器和程序计数器占用几十KB，上下文切换开销很小，且发生于同个CPU上
- 当协程内发生阻塞时，整个线程都会被阻塞

由于多个协程是运行于同一个线程中，为了利用CPU多核支持高并发，可以采用多进程+每个进程单线程多协程的方式，这时每个任务会分配给一个协程来完成

#### 3.3.2 goroutine

##### 1）定义

goroutine不同于co-routine，其是由用户创建的协程，但是会以多对多的方式映射到内核级线程，而不是严格的多对一

##### 2）GMP模型

goroutine使用起来非常方便，只需要`go func()`即可完成调度，这背后是由运行时强大的GMP调度器来支撑的，GMP分别代表如下

- **Goroutine**

  代表一个goroutine

- **Machine**

  代表一个内核级工作线程

- **Processor**

  代表go调度器下的一个处理器，由GOMAXPROCS设定个数，用于存储本地的G队列，**不是**实际的CPU核心

###### （1）GM模型

在Go的初期设计时，只有GM这两个实体，具体调度为多个M去一个全局的G队列获取G，并完成执行，由于访问全局G队列需要获取互斥锁，且大量阻塞操作会使得M在CPU上的切换开销很大，GM模型急需改造

> 这里可以发现，GM模型与Java中的线程池模型非常类似，但是其没有控制内核线程数，且没有提供最大线程数来触发拒绝策略，因而只是一个简化版的线程池

###### （2）GMP模型

此模型下，增加了P这个角色，那么在GMP模型下，G的队列拆分成如下

- 全局队列

  存放全局需要执行的G

- P的本地队列

  存放从该P上生成的一系列G

在运行起初，会根据GOMAXPROCS来创建多个P，之后按如下步骤进行

- 创建M0

- 创建G0

- 将M0和G0关联

- 执行runtime.main函数，完成一些全局的初始化操作

- 创建main.main协程，并将其放入当前绑定的P

- 启动M0

- M0从P中获取到main.main协程，开始执行

- main中如果

  - 有go func()

    创建G放入到P的本地队列

  - 没有go func()

    执行结束后退出

在执行过程中，M会由于操作系统调度（如时间片耗尽），被迫阻塞，这时会创建出新的M来尝试绑定P，来消费P中的G

在调度时，还需要遵循如下规则

- 当本地的P满了（最大256），会截取一半的G放入全局队列
- 当M执行G时发生了wait，会尝试创建或从M的休眠池中获取一个M来接管此G的阻塞
- 每次M从休眠中醒来时（可能是操作系统调度或收到notify信号），都会尝试去绑定一个P
- 当M绑定的P的队列为空时，会尝试从全局队列或者其他P上窃取一些G

>[典藏版 Golang调度器GPM原理与调度全分析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/323271088)
