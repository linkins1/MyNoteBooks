# 1.基础篇

### 1.2 并发编程其他基础

#### 1.2.1 基本概念

##### 1）并行与并发

并行指多个线程同时的在多个CPU上执行

并发指多个线程在同一时间段内交替执行

> 一般线程数要多于CPU核心数，因而一般称为多线程并发编程

##### 2）为何需要多线程并发

尽管多个CPU使得多个线程可以并行执行且独立占用CPU，减少了线程切换的开销，**但是**，在大量请求和海量数据下，多线程并发是必然途径

##### 3）线程安全问题

如果多个线程在更新共享资源时没有进行同步操作，那么可能会存在更新被覆盖的现象，也即更新失败；那么，就必须采取同步方案保证共享资源被安全的读写

#### 1.2.2 内存可见性

##### 1）JMM（Java Memory Model）

JMM规定了**多个Java线程**在主机上运行时，如何安全的读写内存中的共享变量并在必要时保持同步。其不是实际的物理内存结构，是**JVM**在**操作物理内存**时遵循的一种**规范**。开发者可以使用JMM提供的语法集，如volatile来**告知JVM对特定共享变量的操作**，以此来解决多线程并发访问内存中的共享资源时发生的一系列问题

> ***Q：*****JVM中的堆内存和栈与JMM是什么关系？**
>
> ***A：***两者不是同一类概念，JVM中的内存结构指的是JVM对物理内存的逻辑划分，而JMM是多线程环境下操作内存时应遵循的规范

##### 2）硬件内存结构

![image-20201111163625090](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/concurrent/image-20201111163625090.png)

上图为一个双核CPU架构的图示，其中

- 容量

  register<<L1<<L2<<Main

- 速度

  register>>L1>>L2>>Main

其中L1一般用于缓存指令，L2作为L1和主内存之间的缓冲。MESI保证了在访问数据的一致性

##### 3）JVM工作内存

一般来说，Java中的变量全部存储于工作内存中，工作内存包括

- 寄存器
- L1+L2
- 主内存

每个线程在访问共享资源时，会按如下步骤查询

- 如果L1中存在，则返回，否则下一步
- 如果L2中存在，则返回，否则下一步
- 从主内存中取得**副本**，并将其写入两级缓存

##### 4）内存可见性

> ***一句话：我修改了你没看到***

由于每个线程中的缓存是独立的，且从主内存中取得的是原有变量的副本，如果线程A和线程B按如下步骤进行

- 线程A从主内存中获得变量`x`，值为0，取得副本后写入A的L1和L2
- 线程B从主内存中获得变量`x`，值为0，取得副本后写入B的L1和L2
- 线程A更新`x`为1，将其写入L1和L2并更新回主内存
- 线程B再次要读取变量`x`，在L1中就找到，返回为0 ❗❗❗

在最后一步读取`x`时，读取的是本地的滞后的数据，由于A中的L1和L2对B是不可见的，所以B不可以直接读取到A的更新，这就是**内存不可见问题**

#### 1.2.3 synchronized

##### 1）定义

synchronized关键字用于对Java中的任意内置锁（如Java对象或Java类对象）进行操作，也称为**监视器锁**，此锁具有如下性质

- 属于**排他锁**，也即同时只能被一个线程占用
- 属于**可重入锁**，也即可以被一个拿到该锁的线程多次获取
- 具有**原子性**，也即上锁和解锁操作执行是一气呵成的
- **必须**先上锁再使用（如调用wait方法等）
- **运行时不可被中断**，只有在调用了阻塞方法进入阻塞态后才可以被中断

**上锁**的动作有

- 进入同步方法

  - 修饰静态方法

    获取的对象的class实例

  - 修饰实例方法

    获取的是this

  此时同步方法的方法表中会存在一个`ACC_SYNCHRONIZED`字段，那么在线程执行时检测到这个标志位就会先获取监视器锁（也即上面的class实例或者this），在执行完毕或抛出异常后再次释放这个锁

- 进入同步代码

  获取的是给定的对象
  
  这时在进入同步代码块时，会有一个`monitorenter`指令代表获取监视器锁（也即指定的Java对象），在退出同步代码块或发生异常时，会有一个`monitorexit`指令代表释放锁

**解锁**的时机有

- **正常退出**同步方法或同步代码块
- 执行中**抛出异常**
- 执行中调用**wait**方法

##### 2）开销

由于Java中用户级线程和内核级线程采用**一对一**的规则，所以每次进行线程切换执行上锁和解锁操作时，就需要从**用户态切换到内核态**完成，因而synchronized**开销很大**，**但是**，在加入监视器锁的升级机制后，上锁的开销得到了良好改善

##### 3）内存语义

当线程使用synchronized时，可以**保证内存可见性**，这是由于**上锁**和**解锁**操作对应着如下的内存语义

- 上锁

  把synchronized块内使用到的共享变量从线程的**工作内存中清除**

- 解锁

  把synchronized块内使用到的共享变量的值**更新到工作内存**

##### 4）与管程的关系

synchronized底层原理与管程很相似，有如下相似点

- 同时只能有一个线程使用
- 对于第一次竞争锁失败的排队到进入阻塞队列（BLOCKED）
- 对于调用wait方法阻塞，排队到等待队列（WAITING/TIMED_WAITING，必须notify，让其进入就绪态）
- 具有条件变量用于执行阻塞唤醒，具有共享变量用于操作

如下图所示

![img](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/concurrent/2062729-d1cc81ebcf0e912312b.png)

#### 1.2.4 volatile

##### 1）定义

为了避免使用锁带来的巨大开销，可以采用**弱同步的方式**，也即使用volatile，该关键字可以确保一个变量的更新对其他线程马上可见，但是**并不保证原子性**

##### 2）内存语义

对volatile修饰的变量进行读写操作具有如下语义

- 读（类比进入synchronized）

  从主内存中获取值

- 写（类比退出synchronized）

  将变量刷新到主内存

##### 3）适用场景

- 写入值独立于获取值

  在`读-改-写`，的过程中，由于volatile不保证原子性，假设有两个线程同时操作，且其中一个线程操作整体比另一个晚一步，那么最终写出时，就会出现覆盖的现象。

  如果可以保证写入值独立于获取值，那么这一次写操作就是安全的

- 替代锁

  volatile作为锁的弱同步替代，当使用锁时，自然不需要使用volatile
  
- 指令重排序

  在使用共享变量时，由于编译器会使用指令重排序来提高程序运行性能，所以可能会出现多个共享变量赋值顺序颠倒的情况，这在极端情况下会影响到多个线程的正常逻辑。

  通过对作为判断条件的共享变量添加volatile关键字，可以保证其在编译时**不会被重排序**，这就保证了其前后代码的**相对顺序**，从而避免因为赋值顺序颠倒导致的逻辑问题

#### 1.2.5 原子性操作

>主要是指`读-改-写`操作

见如下示例

```java
public class ThreadNotSafeCount{
	private Long value;
	
	public Long getCount(){
		return value;
	}
	
	public void inc(){
		value++;
	}
}
```

这里由于`++`操作不是原子性的，所以会出现读写不安全的现象，有如下两种解决方案

- 使用synchronized

  需要对inc和getCount方法都添加synchronized关键字，这样才可以保证都是对主内存进行操作

- 使用CAS

  这种方式提供非阻塞的原子操作

#### 1.2.6 CAS(Compare And Swap)

> 由于volatile不能保证原子性的操作，因而又提出CAS来保证原子性

##### 1）定义

CAS操作分下面几步进行

- 获取变量x的当前值作为expectedValue
- 想要将x改写为的值记作updateValue
- 再次获取x的value，如果与expecteValue一致，则改写为updateValue，否则不改写

##### 2）ABA问题

###### （1）定义

假设存在下面一种情况

- 线程1拿到变量x的值为A
- 线程2拿到变量x的值为A，将其先改为B，又改为A
- 此时线程1想要将x改写，**获取到当前x的值为A**❗，完成改写

上面注意到，1获取到的x的A已经不是当时他拿到的A，也即x已经被改写过，但是1并不知情。

###### （2）解决

Java中通过`AtomicStampedReference`为变量记录了**时间戳**，这样就可以避免ABA问题

#### 1.2.5 Unsafe类

##### 1）定义

Unsafe类是一个**工具类**，其可以完成对**任意一个对象**中的**域**进行**原子性读写**

##### 2）常用API

- **`long objectFieldOffset(Field feild)`**

  返回**指定的变量**在所属类中的**内存偏移地址**

- `int arrayBaseOffset(Class anayClass)`

  获取数组中第一个元素的地址

- `int arraylndexScale(Class arrayClass)`

  获取数组中一个元素占用的字节

- **`boolean compareAndSwapLong(Object obj, long offset, long expect, long update)`**

  比较对象`obj `中偏移量为`offset `的变量的值是否与`expect`相等， 相等则使用`update`值更新， 然后返回`true`，否则返回`false`

- `public native long getLongvolatile(Object obj, long offset)`

  获取对象obj 中偏移量为offset 的变量对应volatile语义的值

- `void putLongvolatile(Object obj, long offset, long value)`

  设置obj 对象中offset偏移的类型为long 的field 的值为value ，支持volatile 语义

- `void putOrderedLong(Object obj, long offset, long value)`

  设置obj 对象中offset偏移地址对应的long 型field 的值为value 。这是一个有延迟的putLongvolatile 方法，**并且不保证**值修改对其他线程立刻可见。只有在变量使用volatile 修饰并且预计会被意外修改时才使用该方法。

- `void park(boolean isAbsolute, long time)`

  阻塞当前线程， 其中

  - isAbsolute等于false 
    - time 等于0 表示一直阻塞
    - time>0表示等待time时间后唤醒
  - isAbsolute等于true
    - time此时为绝对值

##### 3）使用

一般的使用步骤如下

- 获取Unsafe对象`u`
- 利用`u`获取对应类的字段的偏移量
- 调用`u`中的CAS方法如compareAndSet

但是，这里要注意，由于Unsafe对象在Unsafe类中是单例存在的，如果想获得，必须在**类加载期间**，调用Unsafe的**静态方法**getUnsafe来获得，方法体如下

```java
@CallerSensitive
public static Unsafe getUnsafe() {
    Class var0 = Reflection.getCallerClass();
    if (!VM.isSystemDomainLoader(var0.getClassLoader())) {
        throw new SecurityException("Unsafe");
    } else {
        return theUnsafe;
    }
}
```

这个方法执行如下步骤

- 获取调用类
- 判断此类使用的**类加载器是不是系统类加载器**
  - 如果不是，则抛出异常
  - 如果是，则返回单例

这也就意味着，对于不是`rt.jar`下的类，也就是用户自定义的类，不可以直接调用getUnsafe方法来获得单例，因而用户自定类默认为使用`应用程序类加载器`来加载。

所以，在获取该单例对象时，一般采用**反射机制**来获取

##### 4）示例

```java
public class TestUnsafe {
    static Unsafe unsafe;

    private long num;
    //private static long staticNum=0;

    static {
        try {
            Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
            theUnsafe.setAccessible(true);
            unsafe = (Unsafe) theUnsafe.get(null);

        } catch (NoSuchFieldException | IllegalAccessException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws NoSuchFieldException {
        TestUnsafe testUnsafe = new TestUnsafe();
        Class<? extends TestUnsafe> clazz = testUnsafe.getClass();
        long offset = unsafe.objectFieldOffset(clazz.getDeclaredField("num"));
        //long offsetStatic = unsafe.staticFieldOffset(clazz.getDeclaredField("staticNum"));
        if (unsafe.compareAndSwapLong(testUnsafe, offset, 0, 1))
            System.out.println("修改成功，num=" + testUnsafe.num);
        else
            System.out.println("修改失败，num=" + testUnsafe.num);
    }
}
```

这里步骤如下

- 首先通过反射获取单例Field对象
- 设定为可访问
- 利用get方法获得field对象的值，也即引用的值
- 反射获取目标对象的field对象
- 对于对象中的
  - **实例域**，使用`objectFieldOffset`来获取偏移量
  - **静态域**，使用`staticFieldOffset`来获取偏移量
- 对于实例域，可以采用`compareAndSwapLong`来修改值，**静态域**不可以使用此方法

> 此处《并发编程之美》中利用`objectFieldOffset`方法获取了静态域，会抛出`IllegalArgumentException`
>
> 更多方法[参考](https://www.cnblogs.com/throwable/p/9139947.html)

#### 1.2.6 伪共享

> ***一句话：牵一变量动全缓存行***

##### 1）缓存行

由于CPU和主内存速度的不匹配，因而引入了缓存夹在其中作为缓冲区，在缓存中，为了更好的寻址，将缓存划分为一个个**缓存行**，并给定地址偏移量，为了**更高效的利用缓存行**，**通常将多个字段放入同一个缓存行**，尽可能地减少缓存行中的碎片，如下图所示

![image-20201111105155688](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/concurrent/image-20201111105155688123.png)

##### 2）伪共享

###### （1）定义

前面了解到，线程在获取变量时是从主内存中拉出值并放入对应的工作区域，假设线程**A**要获取变量`x`的值，那么为了方便读写，会将`x`所在的缓存行整块读入到自己的L1+L2缓存，假设同时读取了上图所示的`y`、`z`

此时，假如线程**B**要读取变量`y`的值，同时会将刚刚的缓存行从主存中读入自己的L1+L2级缓存，**之后**，**B**修改了`y`的值，并刷新回主存，根据`MESI`(内存一致性协议)，由于`y`的值已经被改变，所以**A**中的L1和L2缓存中的**缓存行就失效了**，就需要**从主存中重新获取刷新后的缓存行**，由于L1/L2缓存的**速度远远快于**主内存，类似于这样的频繁操作会带来不必要的读写开销。

> ***Q：*****缓存行在单线程下也会出现类似问题吗？**
>
> ***A：***不会，对于单线程来说，由于不存在其他线程干扰，一次读入一个缓存行反而会提高读写效率，因为可以保证在L1/L2内缓存做更多的操作

###### （2）如何解决

前面了解到，是由于多个变量共享了一个缓存行才导致**不必要的缓存行刷新操作**，所以可以采用**填充**的方式，让一个变量占满缓存行，这样就实现了多个变量的**解耦**（不处于一个缓存行）

- `@Contended`

  JDK8中，使用此注解修饰于类或变量上，可以实现对齐填充，避免伪共享

  要注意此注解默认只可修饰于Java核心类，如果用户类想要使用，需要使用`- XX:-RestrictContended`来启用，此时填充的宽度默认为128 ，如果要自定义宽度则可以设置`- XX : ContendedPaddingWidth`参数。

#### 1.2.7 锁概述

#####  1）乐观锁&悲观锁

- 乐观锁

  认为每次线程访问数据都不会对数据进行修改

  为了保证发生修改时可以保证一致性，一般采用使用版本号机制的CAS

- 悲观锁

  认为每次线程访问数据时都会对数据进行修改，那么不论读还是写都会对上锁，直到操作结束才解锁

##### 2）公平锁&非公平锁

- 公平锁

  上锁顺序由线程到达的先后顺序来进行

- 非公平锁

  线程间不存在先后顺序，在锁可用时，所有线程都进入就绪队列参与竞争

假设线程A 已经持有了锁，这时候线程B 请求该锁其将会被挂起。当线程A释放锁后，假如当前有线程C 也需要获取该锁，如果

- 采用非公平锁方式，则根据线程调度策略， 线程B 和线程C 两者之一可能获取锁
- 使用公平锁则需要把C 挂起，让B 获取当前锁

##### 3）独占锁&共享锁

- 独占锁

  保证同时只有一个线程可以拿到锁，是一种悲观锁，如synchronized

- 共享锁

  同时可以有多个线程拿到锁，是一种乐观锁，如读写锁

##### 4）可重入锁

如果一个线程拥有了某个锁，那么其可以多次获得该锁。其在**锁内部维护一个线程标记**，用来标示该锁目前被哪个线程占用，然后**关联一个计数器**。

一开始计数器值为0，说明该锁没有被任何线程占用。

当一个钱程`A`获取了该锁时，计数器的值会变成1 ，这时

- 其他线程再来获取该锁时会发现锁的所有者不是自己而被阻塞挂起
- 当`A`再次获取锁时发现锁拥有者是自己，就会把计数器值加＋ 1，当释放锁后计数器值－1 。当计数器值为0 时，锁里面的线程标示**被重置为null** ， 这时候被阻塞的线程会被唤醒来竞争获取该锁。

##### 5）自旋锁

用户态切换到内核态有两种可能：

- 获取锁成功，需要由用户态切换到内核态进行执行
- 获取锁失败，需要由用户态切换到内核态进入阻塞态等待被唤醒

自旋锁是当线程要获取一个锁时，如果锁被占用，其不会立刻阻塞(切换到内核态)，而是占用CPU继续尝试获取，在多次尝试失败之后才放弃上锁，进入阻塞态。

这么做是因为Java中的线程和内核线程采用一对一的关系，通过自旋锁，可以一定程度上减少切换到内核态的开销

##### 6）锁的状态

JDK1.6之后，**对synchronized锁进行了优化**，引入了四种锁的状态，根据竞争程度的不同，呈下面递增趋势，此趋势也被称为**锁的膨胀**
$$
无锁->偏向锁->轻量级锁->重量级锁
$$

###### Pre：Mark Word

<img src="https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/concurrent/image-20201111161815858.png" alt="image-20201111161815858" style="zoom:80%;" />

JVM中，对象头的第一个字长的部分是Mark Word，锁的状态的修改通过修改这部分即可实现

###### （1）无锁

不上锁，所有的线程都可以对共享变量修改，但是只有一个线程可以修改成功，这种方式也即采用**CAS**算法，由于CAS需要一直循环尝试直到修改成功，所以此时线程内对共享变量的修改动作一般都**发生在循环体内**

此时mark word前30个bit存储对象的hashcode和对象的分代年龄，偏向锁标志位为0，状态为01

###### （2）偏向锁

由于在获取锁时，通常采用CAS方式进行竞争，为了减少在大多数情况下只有一个线程访问共享变量（竞争不激烈）的情况下获取锁的开销，提出使用偏向锁，由于偏向锁机制是**默认**开启的，且由于一般使用synchronized关键字时，不会采用自旋CAS的方式来修改共享变量，**所以**，在开启偏向锁时，进入synchronized代码块时一般为无锁（无状态）转化为偏向锁，上锁时会将Mark Word中的偏向锁标志位置为1。

>在使用`-XX:-UseBiasedLocking=false`关闭偏向锁机制时，会从无锁状态直接升级为轻量级锁

:one: **特征**

偏向锁具有**如下特征**

- 通过**CAS方式**修改锁的对象头中的**偏向线程ID**和**偏向时间戳**来实现上锁
- 避免了**持锁线程**再次获取时执行**CAS**的开销，只需要比较**两个标记**即可
- 要注意获取了偏向锁的线程**不会主动释放锁**，而是等到竞争出现再做判断

:two: **上锁与撤销**

假设线程`A`要获取偏向锁，其**上锁过程**如下：

访问 Mark Word 中偏向锁的标志是否设置成`1`，锁的标志位是否是`01 `，以此来确定是否为**可偏向状态**，（这里主要是检查偏向锁标志是否为`1`（代表是否有偏向锁），因为无锁状态的标志位也是`01`），

- 如果是，判断**当前线程id**和**偏向线程ID**是否一致，
  - 如果一致，则代表`A`已经持有了该偏向锁，这时会在当前线程的栈中创建一个`Displaced Mark Word`为空的`Lock Record`，当`A`释放锁时，会将此位置置为null，这也是其他线程CAS竞争偏向锁时**判断占有偏向锁线程是否存活**的依据
  - 如果不一致，`A`通过 **CAS** 操作来竞争获取锁，
    - 如果是初次竞争，则按照**CAS**的规则，如果`A`竞争成功，则将**偏向线程ID**修改为**当前线程ID**
    - 如果不是初次竞争，则表示**已有其他线程**持有该偏向锁（获取偏向锁的线程不会主动释放该锁），当到达**全局安全点**（SafePoint）时(**此时没有字节码执行**)，会**首先暂停拥有偏向锁的线程**，然后检查持有偏向锁的线程`B`**是否还占用偏向锁或者存活**，
      - 如果线程`B`仍然占用锁，则**撤销**其占有的偏向锁并**升级到轻量级锁**的状态（`00`），继续执行其同步代码，`A`和其他剩余的线程通过**自旋**来竞争获得升级后的**轻量级锁**
      - 如果线程`B`不占用锁或已消亡，则**撤销**其占有的偏向锁，并将对象头置为**无锁状态**(`01`)，然后按照将**偏向锁**标志位设定为0，下一次上锁直接升级为轻量级锁
- 如果不是，则使用CAS竞争锁（正常的竞争锁，没有偏向锁）

综上所述，上锁过程需要根据不同情况做出调整，而撤销只会有两种结果：升级为轻量级锁或降级为无锁

![img](https://pic1.zhimg.com/80/v2-29784bd4ae4d9786d943710fe06499af_720w.jpg?source=1940ef5c)

:three: **如何理解偏向**

其**“偏向”**这一性质体现于，对于线程`A`假设其已经占有偏向锁，那么

- 在大多数**没有竞争的**情况下，线程A每次省去了CAS的上锁操作，因为锁的对象头中存储的信息和自己匹配，这个锁也就偏向于`A`，这样便提升了上锁效率
- 而对于竞争剧烈的情况下，会根据`A`是否仍然占用锁会将其升级为轻量级锁或者直接回退至无锁状态

>通过JVM参数关闭偏向锁：`-XX:-UseBiasedLocking=false`，此时程序默认会进入轻量级锁状态

**:four: 批量重偏向和撤销**

假设有下面两种场景

- 当一个线程创建了大量对象并执行了初始的同步操作，后来另一个线程也来将这些对象作为锁对象进行操作
- 存在明显多线程竞争的场景

上面两种场景下偏向锁有具体的优化策略

- 为了第二个线程对同类对象做大量的偏向锁撤销并升级为轻量级锁的操作，可以设定阈值（intx BiasedLockingBulkRebiasThreshold），当对同类对象的撤销次数大于阈值时，就会对后面的同类对象进行批量重偏向

  要注意，上面场景仅限于大于批量重偏向阈值且两个线程先后对同类大量对象做synchronized操作时

- 当大于两个线程对同类大量对象做synchronized操作时，当超过设定阈值（intx BiasedLockingBulkRevokeThreshold）时，就会将后续的同类对象做批量撤销操作

  要注意，上面场景仍是针对大量同类对象的操作，只不过是大于两个线程操作

可见，为了对同类对象的偏向锁竞争情况做记录，需要在class对象中对此类的所有对象的偏向锁情况做记录，计数值的增长原则是对象被二次竞争偏向锁的情况，也即在对象已经被某线程设为偏向锁时，其他线程每对此类对象做一次偏向操作就会触发一次计数

此外，

- 被重偏向的对象不可以再次被重偏向，只能被升级为轻量级锁
- 已经触发批量撤销的类，其后续创建的对象不允许使用偏向锁机制，只能直接从无锁到轻量级锁
- 批量撤销只在对同一对象第三次偏向时触发，对于后续对象，不论是否重偏向过，一律撤销并升级为轻量级锁

> **# 参考**
>
> [盘一盘 synchronized （二）—— 偏向锁批量重偏向与批量撤销 - 柠檬五个半 - 博客园 (cnblogs.com)](https://www.cnblogs.com/LemonFive/p/11248248.html#:~:text=批量重偏向：当一个,锁重偏向的操作。)
>
> [死磕Synchronized底层实现--概论 (juejin.cn)](https://juejin.cn/post/6844903726545633287)

###### （3）轻量级锁

在前面偏向锁竞争的过程中如果发生了升级为轻量级锁，那么便按照轻量级锁的规则执行

:one: **特征**

轻量级锁也可以理解为自旋锁，所有要竞争获取该锁的，都会**自旋地**获取该锁，那么进行自旋操作的线程最终只有两种状态

- 抢到锁，进入运行态
- 自旋次数超限，进入阻塞态

:two: **上锁**

其上锁的方式有两种

- 通过将占用偏向锁的线程升级为轻量级锁获得
- 通过自旋竞争的方式获得

假设线程`A`要获取锁，其**上锁**的过程如下

- 如果锁对象为**无锁状态**（锁标志位为`01`状态，是否为偏向锁为`0`），虚拟机首先将在**线程`A`的栈帧**中建立一个名为`锁记录(Lock Record)`的空间，将目前的`Mark Word`的拷贝放入此空间中，称作`Displaced Mark Word`
  - 通过**CAS**将**锁对象头**中的`Mark Word`的前30bit修改为**指向`A的锁记录`的指针**（关键!），并修改状态标志位为`00`
    - 如果成功，则`A`获取到锁
    - 否则，开始自旋地通过**CAS**获取锁
      - 如果成功，则修改Mark Word，进入临界区
      - 如果失败，则代表存在大量竞争，**升级为重量级锁**
- 如果锁对象是从**偏向锁升级为轻量级锁**的，则被升级的线程直接获取锁，其他线程自旋的通过CAS获取该锁，同样的，如果失败则升级为重量级锁

:three: **解锁**

持有自旋锁的线程在解锁时，需要将之前备份好的`Displaced Mark Word`通过**CAS**的方式放回锁对象头的`Mark Word`中，由于放回操作会和其他通过CAS竞争拷贝Mark Word的线程竞争，如果**放回操作失败**，同样意味着存在大量竞争，**则升级为重量级锁**

**综上所述**，升级为重量级锁可以发生在拷贝或者替换`Mark Word`的时候，只要存在大量竞争就会升级为重量级锁

> ***Q：*****从无锁状态转换到轻量级锁一般发生于什么时候？**
>
> ***A：***无锁状态到轻量级锁的转变一般发生于禁用偏向锁时，其余状态为从偏向锁状态到轻量级锁状态

###### （4）重量级锁

:one: **特征**

重量级锁也即通常说的对象锁，其具有synchronized默认的一切特征，通过互斥量实现

:two: **上锁与解锁**

根据synchronized修饰的是方法还是代码块，分别有不同的操作，但是仍然是同时只有一个线程可以占有

:three: **升级**

在轻量级锁升级为重量级锁时，常见情况如下

线程1想要CAS解锁（放回`Displaced Mark Word`），同时线程2想要CAS的上锁（拷贝`Mark Word`）如果失败，

- 线程2会将锁对象头中的Mark Word的前30位替换为该锁的指针，进入**阻塞状态**
- 因为CAS尝试次数相同，线程1通常会晚于线程2失败，在没有放回`Displaced Mark Word`的情况下，会释放轻量级锁，**并唤醒线程2**，这样线程2就获得了重量级锁，进入同步代码块，之后的上锁与解锁就按照synchronized的规定执行

>***Q：*****重量级锁会回退至轻量级锁吗？**
>
>***A：***不会，由于轻量级锁的自旋操作开销很大，所以一般升级为重量级锁后不会回退


#### # 附

[**既然CPU有缓存一致性协议（MESI），为什么JMM还需要volatile关键字？ - 知乎 (zhihu.com)**](https://www.zhihu.com/question/296949412)

[**JVM内存结构**、**Java内存模型**和**Java对象模型**](https://www.hollischuang.com/archives/2509)

