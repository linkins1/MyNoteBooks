## 1.JVM概述

### 1.1 基本概念

#### 1.1.1定义

[Java虚拟机]([https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA](https://zh.wikipedia.org/wiki/Java虚拟机))（英语：Java Virtual Machine，缩写为JVM），一种能够运行**Java 字节码**的虚拟机，以堆栈结构机器来进行实现。最早由Sun微系统所研发并实现第一个实现版本，是Java平台的一部分，能够运行以Java语言写作的软件程序。

Java虚拟机有自己完善的硬件架构，如**处理器、堆栈、寄存器**等，还具有**相应的指令系统**。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。通过对中央处理器（CPU）所执行的软件实现，实现能执行编译过的Java程序码（Applet与应用程序）。

作为一种编程语言的虚拟机，实际上**不只是专用于Java语言**，只要生成的编译文件**符合JVM对加载编译文件格式**要求，任何语言都可以由JVM编译运行。此外，除了甲骨文，也有其他开源或闭源的实现。

> JVM可以看作是一个用来解释运行字节码的平台(虚拟机)，作为字节码文件和操作系统**之间的一层**，运行在**不同平台上的JVM**将字节码编译为机器码，并经由操作系统来完成机器码的执行
>
> <img src="https://img2020.cnblogs.com/blog/1846149/202004/1846149-20200401104340482-1757970137.png" alt="img" style="zoom: 67%;" />

#### 1.1.2架构图

<img src="/resources/imgs/jvm/image-20200904162122124.png" alt="image-20200904162122124" style="zoom:80%;" />

如上图所示，JVM收到字节码后会经历以下步骤

- **1）**加载class文件
- **2）**将初始化好的内容放入运行时数据区域，对于执行中的方法会形成栈帧。此外，如果是调用的本地方法，那么会在本地方法栈中存储记录，且会调用本地方法接口(JNI)以及本地方法库
- **3）**调用执行引擎对准备好的代码进行解释以及执行，对于热点代码，**JIT**(Just-In-Time)编译器会将其编译成机器码以便于多次重复调用，加快执行时间，因为此编译行为发生在程序运行期间，所以该编译器被称为编译器。此外，垃圾收集器会将野指针进行回收以避免内存泄漏的问题

#### 1.1.3指令集

##### 1）JVM的指令集 

JVM的指令集的**种类少**，**指令流采用栈的结构**，使用零地址指令分配方式，解决了寄存器的分配问题。由于指令集种类少，因而需要大量的指令来完成制定的操作，因而执行效率会差于基于寄存器架构的指令。

> **零地址：**代表只有操作码，没有地址码

##### 2）与基于寄存器架构的区别

###### （1）基于栈架构

- 基于栈架构的指令可移植性更好，不需要分配硬件地址
- 指令流的大部分指令都是零地址指令，执行过程依赖于操作栈

###### （2）基于寄存器

- 指令架构依赖于硬件平台，可移植性差
- 性能高效，指令集数量多，指令少

###### （3）示例

执行1+1的操作

- （1）基于栈

```text
iconst_1
iconst_1
iadd
istore_0
```

- （2）基于寄存器

```text
mov eax,1
add eax,1
```

#### 1.1.4生命周期

##### 1.4.1启动

JVM通过引导类加载器创建一个initial class来完成启动

##### 1.4.2执行

一个Java程序在执行时会在JVM中占用一个进程

##### 1.4.3退出

- 当Java程序正常结束时，JVM中对应的进程也结束
- 出现异常退出，如OOM错误
- 操作系统错误退出
- 调用exit退出

### 1.2发展历程

下面摘自[JVM历史](https://www.cnblogs.com/chanshuyi/p/jvm_serial_02_the_history_of_jvm.html)

- 1996 年，JDK 1.0 发布时，提供了纯解释执行的 Java 虚拟机实现：Sun Classic VM。
- 1997 年，JDK 1.1 发布时，虚拟机没有做变更，依然使用 Sun Classic VM 作为默认的虚拟机。
- 1998 年，JDK 1.2 发布时，提供了运行在 Solaris 平台的 Exact VM 虚拟机，但此时还是用 Sun Classic VM 作为默认的 Java 虚拟机。
- 2000 年，JDK1.3 发布，默认的 Java 虚拟机由 Sun Classic VM 改为 Sun HotSopt VM，而 Sun Classic VM 则作为备用虚拟机。
- 2002 年，JDK 1.4 发布，Sun Classic VM 退出商用虚拟机舞台，直接使用 Sun HotSpot VM 作为默认虚拟机一直到现在。
