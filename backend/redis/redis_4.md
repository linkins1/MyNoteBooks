## 4.Redis持久化

### 4.1RDB（Redis DataBase）

#### 4.1.1原理

在**指定的时间间隔**内将内存中的**数据集快照（Snapshot）写入磁盘**，在恢复时是将快照文件直接读到内存里。快照文件默认为dump.rdb

Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时rdb文件中，待持久化过程都结束了，再用这个临时rdb文件**替换**上次用于持久化的rdb文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能

上面提到的时间间隔即为持久化的策略，以及rdb文件的名称和保存路径，这三者都可以通过配置文件进行修改

#### 4.1.2配置

##### 1）dump.rdb

有关的配置有如下两个

:one: `dbfilename dump.rdb` 可以通过这个来修改文件名，后缀一般不变，在需要配置多个redis时修改dump编号

:two: `dir ./` 默认为启动redis的路径，对于docker安装的方式，启动路径即为指定的数据保存路径

> 使用CONFIG GET dir可以获取到配置的dir路径

##### 2）时间策略

默认的时间间隔策略有如下几种

```shell
save 900 1 #超过900s且有至少1个key变动，则触发保存---长期少量
save 300 10 #超过300s且有至少10个key变动，则触发保存---中期中量
save 60 10000 #超过60s且有至少10000个key变动，则触发保存---短期大量
```

上面三种策略同时生效，如果想要禁用rdb策略，只需要配置如下

```shell
save ""
```

#### 4.1.3手动触发保存

##### 1）save

通过save会立即阻塞所有操作并进行rdb文件的持久化

##### 2）bgsave

通过bgsave可以在后台异步的完成rdb文件持久化，可以通过lastsave获取最近一次的保存时间

##### 3）flushall

即使是清空所有数据库，也会触发一次rdb文件的持久化，只不过为空

#### 4.1.4常用策略

一般为了避免宕机带来dump文件损坏或者保存失效，可以用下面三种方式弥补（仅限于rdb策略下）

##### 1）限于rdb策略下

###### （ 1）修复rdb文件

通过redis-check-dump脚本，可以修复收到损坏的rdb文件

######  （2）冷拷贝

将rdb文件手动拷贝到另一台机器中，当本机出现故障时，可以将此备份覆盖到本地，完成恢复

##### 2）使用aof策略

即使在rdb文件没有损坏的情况下，由于**是按照时间间隔进行持久化**，所以可能会出现**最后一次数据没有成功持久化**的情况，所以可以使用aof策略进行辅助

### 4.2AOF（Append Only File）

#### 4.2.1原理

##### 1）创建并续写aof文件

AOF是以**日志的形式来记录每个写操作**，将Redis执行过的所有写指令记录下来(**读操作不记录**)，一般保存为**appenonly.aof**，对此文件只许**追加**但不可以改写，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作

##### 2）重写aof文件

AOF采用文件追加方式，文件**会越来越大**。为解决这个问题，新增了重写机制,当AOF文件**大小超过所设定的阈值**时，会**fork出一条新进程**来进行重写(也是先写临时文件最后再rename)。

重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用**最少的命令**的方式重写了一个新的aof文件，这点和快照有点类似，文件中只保留可以恢复数据的最小指令集。

可以使用命令**bgrewriteaof**来后台完成压缩

#### 4.2.2配置

##### 1）appendonly.aof

:one: apppendonly yes

这个配置用于指示是否打开aof支持，默认为no

:two: appendfilename xxx

这里可以指定aof文件的名称，默认为appendonly

:three: no-appendfsync-on-rewrite no

由于在开启bgsave和bgrewriteof时，会进行大量的IO操作，此时可能会阻塞很久appendonly.aof的输出操作，为了中和这个情况，可以这个选项开启，也即在进行后台IO操作时，不输出aof文件，开启后，最差可能会损失30s的日志记录。在阻塞不严重时，可以就设定为默认的no

:four: auto-aof-rewrite-percentage 100

100意味着如果aof文件增加到上一次重写后的aof文件的大小的一倍时，就需要开始重写aof文件

:five: auto-aof-rewrite-min-size 64mb

64mb为触发重写的下限，避免了aof文件满足了一倍的大小规则，但是仍然很小时触发的无意义的重写操作

##### 2）同步策略

:one: appendfsync always

每次发生数据变更会被立即记录到磁盘 ，性能较差但数据完整性比较好

:two: appendfsync sec(默认)

异步操作，每秒发生数据变更会被立即记录到磁盘， 如果一秒内宕机，有数据丢失

:three: appendfsync no

不进行同步

#### 4.2.3常用策略

##### 1）修复aof文件

通过redis-check-aof脚本，可以修复收到损坏/被恶意篡改的aof文件

##### 2）冷拷贝

将aof文件手动拷贝到另一台机器中，当本机出现故障时，可以将此备份覆盖到本地，完成恢复

### 4.3RDB与AOF对比

#### 4.3.1优劣势

##### 1）RDB

###### （1）优势

:one: 文件简单，读写快，适合大规模的数据恢复

:two: 对数据完整性和一致性要求不高时更适用

###### （2）劣势

:one: fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑

:two: 在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改动态

##### 2）AOF

###### （1）优势

:one: 可以通过指定三种不同的fsync策略来进行文件追加，最多只丢失一秒的数据

:two: 由于是纯追加式的文件，当出现损坏时容易修复

:three: 即使使用flushall命令清空了所有数据，对于aof文件而言，也只是在文件的最后一行记录了flushall，不会像dump文件被彻底清空，只需删除这一句即可再次进行数据恢复

###### （2）劣势

:one: aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同

:two: 在相同数据集的条件下，aof文件一般比rdb大，恢复速度也较慢

#### 4.3.2优先级

当rdb和aof策略同时开启时，在进行数据恢复的过程中aof会优先被加载，因为aof中的记录更加完整和精确。

**但是！**不可以只开启aof策略，因为rdb更适用于海量的数据备份，且性能会优于aof，一般用于aof的辅助，存放于从机上。

此外，为了减少aof文件输出时对IO设备的占用，一般会增大auto-aof-rewrite-min-size的大小，来避免频繁的IO占用
