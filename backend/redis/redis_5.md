## 5.Redis事务

### 5.1 Redis的部分事务支持

#### 5.1.1 定义

可以**一次执行多个命令**，本质是**一组命令的集合**。一个事务中的**所有命令都会序列化**，按顺序地串行化执行而不会被其它命令插入，不许加塞。

对于Redis来说，其事务也即将一组命令（语法错误的命令也会入队）按顺序放入一个**队列**中，对队列中的命令一次性做处理。

#### 5.1.2 相关命令

##### 1）MULTI

调用MULTI打开事务，之后的写的每一句命令都会按顺序入队

##### 2）EXEC

将所需的命令都入队后，调用EXEC即可

##### 3）DISCARD

如果想撤销刚刚构建的队列，直接调用DISCARD即可

#### 5.1.3 事务的生效与撤销

对于放入队列中的命令，执行时会出现下面四种情况

##### 1）正常执行

如果队列中的命令不存在语法错误，那么就可以直接调用EXEC完成队列中所有命令的执行

##### 2）事务失效

由于命令不论是否存在语法错误都会入队，所以在调用EXEC时如果某个命令出现错误，那么就会**撤销整个队列**



![image-20201009102532100](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/redis/image-20201009102532100.png)

##### 3）撤销事务

可以直接手动调用DISCARD来将整个队列都手动撤销

##### 4）部分撤销

如果队列中没有语法错误的命令，但是其中存在指令和操作数不匹配的情况，如对一个非数字类型的键值对调用INCR/DECR那么就会出现错误，这时只会将出现错误的命令撤销而不会撤销正确的命令

![image-20201009103003065](https://cdn.jsdelivr.net/gh/linkins1/MyNoteBooks/resources/imgs/redis/image-20201009103003065.png)

>部分撤销可以类比于运行时异常，事务失效可以类比于受查异常

### 5.2 Redis的监控

#### PRE-乐观锁&悲观锁

##### 1）悲观锁

###### （1）定义

悲观的加锁，认为每个在读取数据的线程都会对数据进行修改，因而进行每一次操作都需要进行加锁，阻塞其他访问。

###### （2）示例

:one: Mysql中的表锁、行锁等都是悲观锁

:two: Java中的synchronized关键字

###### （3）适用场景

大量写少量读的操作

##### 2）乐观锁

###### （1）定义

乐观的加锁，认为每个在读取数据的线程不会对数据进行修改，因而来读取的线程都可以拿到数据，但是，如果要进行更新，就需要有策略来保证结果的正确性。常用的策略有两种

:one: 版本号(Version Control)

版本号策略为每个字段都追加了版本号属性，代表是第几次更新的结果。其规定了进行一次更新操作的步骤如下

-  获取当前的版本号为OldVersion

- 对数据进行更新，定义新的版本号NewVersion=OldVersion+1
- 按照OldVersion查看版本号，如果版本号一致，则更新为NewVersion；否则，代表该字段的版本号被修改过，放弃更新

:two: CAS（Check And Set）

与版本号策略类似，CAS规定了进行一次更新操作的步骤如下

- 读取数据记录为ExpectedValue，并获取当前数据的内存位置address
- 对数据做出更新为NewValue后，按照address查找到当前数据的值NowValue，如果NowValue等于ExpectedValue，那么就更新为NewValue；否则，代表该字段已经被其他人更新过，放弃更新

###### （2）示例

Redis的监控机制

###### （3）适用场景

大量读少量写的操作

#### 5.2.1 定义

通过对某个k-v对进行监控，保证在构建事务的过程中，事务中所涉及的变量不会有第三者进行改动，如果有人改动，那么整个事务会回滚。

#### 5.2.2 相关命令

##### 1）WATCH

开启对某个字段的监控，也就相当于为该字段加了乐观锁

##### 2）UNWATCH

关闭对某个字段的监控

#### 5.2.3 示例

> 下面为[马丁传奇的例子](https://www.cnblogs.com/martinzhang/p/3415204.html)

| 客户端1                                                      | 客户端2                                                      | 说明                                                         |
| :----------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| redis 127.0.0.1:6379> get age<br/>"10"<br/>redis 127.0.0.1:6379> get name<br/>"zhangsan" | redis 127.0.0.1:6379> get age <br />"10" <br />redis 127.0.0.1:6379> get name <br />"zhangsan" | 数据库中两客户端登录，及键初始值。                           |
| redis 127.0.0.1:6379> **watch age name** <br />OK <br />redis 127.0.0.1:6379> **multi** <br />OK redis <br />127.0.0.1:6379> **incr age** QUEUED <br />redis 127.0.0.1:6379> **set name lisi** <br />QUEUED |                                                              | 此时，客户端1用watch命令监视age和name，然后开启事务，并提交队列命令 |
|                                                              | redis 127.0.0.1:6379> **incr age** <br />(integer) 11        | 此时，客户端2修改了age值                                     |
| redis 127.0.0.1:6379> **exec** <br />(nil) <br />redis 127.0.0.1:6379> get age <br />"11" <br />redis 127.0.0.1:6379> get name <br />**"zhangsan"** |                                                              | 此时，客户端1执行队列命令，由watch监控发现此期间age的值**已经被修改过，则让事整个事务回滚**，不做任何动作。  watch可以同时监控多个键，在监控期间只要有一个键被其它客户端改变，则整个事务回滚。 |

如上面的情况所示，由于age字段已经被修改，因而name也没有被修改为lisi

#### 5.3 何为部分事务支持

从上面的**事务失效和部分撤销**这两种情况可以看出，事务只是针对于指令本身出现语法错误时才会生效，在指令看上去没问题但是操作的类型不正确时，也就不存在事务

另外，可以通过监控机制在一定程度上达到的事务的特性。